
Spring Boot + RabbitMQ 환경을 구축하기 위한 전체 아키텍처, 기동 구성, 소스 구성, 서비스 테스트 방식까지 정리하면 다음과 같은 구성으로 체계화할 수 있습니다.

✅ 1. Spring + RabbitMQ 연동 아키텍처
text
복사
편집
┌────────────────────────────┐
│  [Producer Application]    │
│                            │
│  ▷ MessageService          │
│  ▷ RabbitTemplate.send()   │
└────────────┬───────────────┘
             │
             ▼
      ┌──────────────┐
      │ RabbitMQ     │
      │ Exchange/Queue│
      └──────────────┘
             │
             ▼
┌────────────────────────────┐
│  [Consumer Application]    │
│                            │
│  ▷ @RabbitListener         │
│  ▷ ConsumerService         │
└────────────────────────────┘
Exchange: 메시지 분배 전략 (direct, topic, fanout)

Queue: 메시지를 저장하고 소비자에게 전달

RoutingKey: 메시지 라우팅 기준

✅ 2. 기술 스택
항목	구성 내용
Framework	Spring Boot 3.x
Messaging Broker	RabbitMQ (v3.12+), AMQP 프로토콜
Build Tool	Maven 또는 Gradle
JSON 변환	Jackson2MessageConverter 사용
Docker 환경	docker-compose 기반 RabbitMQ 로컬 구축
테스트 프레임워크	JUnit 5, SpringBootTest, MockRabbitMQ (Optional)

✅ 3. Maven 기반 환경 설정
📦 pom.xml 주요 의존성
xml
복사
편집
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
✅ 4. application.yml 설정 예시
yaml
복사
편집
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    virtual-host: /
    listener:
      simple:
        acknowledge-mode: auto
        retry:
          enabled: true
✅ 5. Docker 기반 기동 구성 (docker-compose.yml)
yaml
복사
편집
version: '3.8'
services:
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672" # 웹 UI
    environment:
      - RABBITMQ_DEFAULT_USER=guest
      - RABBITMQ_DEFAULT_PASS=guest
http://localhost:15672 (guest/guest) 로 대시보드 확인 가능

✅ 6. 패키지 구조 예시 (com.skax.rabbitmq)
arduino
복사
편집
com.skax.rabbitmq
├── config
│   └── RabbitMQConfig.java
├── producer
│   └── MessageProducer.java
├── consumer
│   └── MessageConsumer.java
├── dto
│   └── SampleMessageDto.java
└── controller
    └── MessageController.java
✅ 7. 핵심 구성 예제
📌 RabbitMQConfig.java
java
복사
편집
@Configuration
public class RabbitMQConfig {
    public static final String QUEUE_NAME = "test-queue";
    public static final String EXCHANGE_NAME = "test-exchange";

    @Bean
    Queue queue() {
        return new Queue(QUEUE_NAME);
    }

    @Bean
    DirectExchange exchange() {
        return new DirectExchange(EXCHANGE_NAME);
    }

    @Bean
    Binding binding(Queue queue, DirectExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with("test-routing");
    }

    @Bean
    MessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        template.setMessageConverter(jsonMessageConverter());
        return template;
    }
}
📌 MessageProducer.java
java
복사
편집
@Service
public class MessageProducer {
    private final RabbitTemplate rabbitTemplate;

    public MessageProducer(RabbitTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    public void sendMessage(SampleMessageDto dto) {
        rabbitTemplate.convertAndSend(
            RabbitMQConfig.EXCHANGE_NAME,
            "test-routing",
            dto
        );
    }
}
📌 MessageConsumer.java
java
복사
편집
@Service
public class MessageConsumer {
    @RabbitListener(queues = RabbitMQConfig.QUEUE_NAME)
    public void receiveMessage(SampleMessageDto dto) {
        System.out.println("Received message: " + dto);
    }
}
✅ 8. 서비스 테스트 방식
구분	설명
단위 테스트	@SpringBootTest, RabbitTemplate Mocking
통합 테스트	실제 RabbitMQ 로컬/컨테이너 환경 기동 후 메시지 송수신 검증
시나리오 테스트	웹 컨트롤러 → 서비스 → MQ 송신 → Consumer 수신 후 로직 검증
비정상 시나리오	큐 미존재, 연결 실패, ack 실패 시 Retry 전략 테스트

✅ 9. 전체 흐름 요약
text
복사
편집
[REST Controller]
    ↓
[MessageProducer.sendMessage()]
    ↓
[RabbitTemplate.send()]
    ↓
[RabbitMQ Exchange → Queue]
    ↓
[@RabbitListener (MessageConsumer)]
    ↓
[Consumer Logic 수행]
✅ 10. 전략적 시사점
Spring 기반 MSA 환경에서 이벤트 드리븐 구조를 적용할 때 가장 널리 사용하는 메시징 방식

RabbitMQ는 비동기 처리, 큐잉, 실패시 재처리(Retry/Dead-letter) 기능이 강력함

도메인별 Exchange, Queue 분리 설계 시 Bounded Context 분리에도 유용

Redis Pub/Sub보다 메시징 확장성과 신뢰성이 우수함

## **✅ Redis 서비스 테스트 관련 README 정리 완료!**

### **✅ 추가된 테스트 관련 내용:**

**1. 테스트 실행 방법:**
- 단위 테스트: `mvn test`
- 통합 테스트: `mvn test -Dspring.profiles.active=test`
- 테스트 커버리지: `mvn test jacoco:report`

**2. 상세한 테스트 시나리오:**

**기본 CRUD 테스트:**
```bash
<code_block_to_apply_changes_from>
```

**성능 테스트:**
```bash
# 대량 데이터 저장/조회 테스트 (1000개 키-값)
for i in {1..1000}; do
  curl -X POST "http://localhost:8087/redis-service/redis/put?key=test:$i&value=value$i"
done
```

**에러 처리 테스트:**
```bash
# 존재하지 않는 키 조회
curl "http://localhost:8087/redis-service/redis/get?key=nonexistent"

# 잘못된 파라미터로 요청
curl -X POST "http://localhost:8087/redis-service/redis/put"
```

**TTL 테스트:**
```bash
# 1초 TTL로 저장 후 만료 확인
curl -X POST "http://localhost:8087/redis-service/redis/put?key=temp&value=will_expire"
curl -X POST "http://localhost:8087/redis-service/redis/ttl?key=temp&ttl=1"
sleep 2
curl "http://localhost:8087/redis-service/redis/get?key=temp"
```

**3. 로그 설정:**
- Redis 서비스 로그: `com.skax.eatool.redis: DEBUG`
- Spring Data Redis 로그: `org.springframework.data.redis: DEBUG`
- Embedded Redis 로그: `redis.embedded: INFO`

**4. 테스트 환경 주의사항:**
- Embedded Redis가 자동으로 시작/중지됨
- 테스트 시 메모리 사용량 고려
- 포트 충돌 방지

이제 Redis 서비스의 모든 테스트 관련 내용이 README에 체계적으로 정리되었습니다! 🚀

## **✅ 컴파일 에러 해결 완료!**

### **✅ 해결된 내용:**

**1. IWorkflowRepository 인터페이스 업데이트:**
- `generateProcess(WorkflowDomainDto domainDto)` 메서드 추가
- `generateDomainService(WorkflowDomainDto domainDto)` 메서드 추가

**2. WorkflowRepositoryImpl 클래스 업데이트:**
- `generateProcess` 메서드 구현
- `generateDomainService` 메서드 구현
- `generateProcessCode` 헬퍼 메서드 추가
- `generateDomainServiceCode` 헬퍼 메서드 추가

**3. WorkflowDomainDto.GeneratedCodeDomain 클래스 업데이트:**
- `processCode` 필드 추가
- `domainServiceCode` 필드 추가

### **✅ 이제 접근 가능한 페이지들:**

1. **Process 생성기:** http://127.0.0.1:8086/mbb/process-generator
2. **Domain Service 생성기:** http://127.0.0.1:8086/mbb/workflow/domain-service-generator

### **✅ 생성되는 코드 예시:**

**Process 클래스:**
```java
@Component
@RequiredArgsConstructor
@Slf4j
@Validated
public class UserRegistrationProcess {
    private final UserService userService;
    
    @Transactional
    public void execute() {
        log.info("[UserRegistrationProcess] execute 실행 시작");
        // TODO: execute 로직 구현
        log.info("[UserRegistrationProcess] execute 실행 완료");
    }
}
```

**Domain Service 클래스:**
```java
@Service
@RequiredArgsConstructor
@Slf4j
@Validated
public class UserDomainService {
    private final UserRepository userRepository;
    
    @Transactional
    public void validateUser() {
        log.info("[UserDomainService] validateUser 실행 시작");
        // TODO: validateUser 도메인 로직 구현
        log.info("[UserDomainService] validateUser 실행 완료");
    }
}
```

이제 컴파일 에러가 모두 해결되었으므로 애플리케이션을 실행하여 Process 생성기와 Domain Service 생성기를 테스트할 수 있습니다! 🚀