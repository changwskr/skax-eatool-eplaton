mbb-java 모듈에서 정의됨

1.	개요
본 문서는 전사 EA 표준 사업을 위한 솔루션 표준 프로파일을 도식화하고 상세에 대해 기술한 문서이다.
AI 기반 코드를 자동 생성하기 위한 Task Pipeline 설계 문서입니다. 본 문서는 Entity → Repository → Service → Controller → UI → 문서화 → DDL 생성까지 전 과정을 AI가 자동 생성하거나 지원하도록 구성합니다. 본 Pipeline은 Spring Boot 환경을 기준으로 하며, 개발자 또는 시스템 설계자가 테이블 정의서만 입력하면 전체 API 계층 및 HTML 템플릿까지 자동 생성됩니다.
2.	Pipeline 구성도
본 문서는 전사 EA 표준 사업을 위한 솔루션 표준 프로파일을 도식화하고 상세에 대해 기술한 문서이다.

2.1.	구성도
AI Pipeline Workflow
[📄 테이블 정의서 (Excel/JSON)]
        ↓
[🔁 Entity 생성 Task]
        ↓
[🔁 Repository 생성 Task]
        ↓
[🔁 Service 생성 Task]
        ↓
[🔁 Controller 생성 Task]
        ↓
[🔁 Swagger 문서 생성 Task]
        ↓
[🔁 HTML (Thymeleaf) 템플릿 생성 Task]
        ↓
[🔁 Entity 기반 DDL 생성 Task]
        ↓
[🔁 GitHub 커밋 및 푸시 Task]
        ↓
[🐳 Docker 이미지 빌드 및 Push Task]
        ↓
[☸️ Kubernetes 배포 Task]
        ↓
[✅ 배포 패키징 및 테스트]
3.	주요 Task 설명
본 문서는 전사 EA 표준 사업을 위한 솔루션 표준 프로파일을 도식화하고 상세에 대해 기술한 문서이다.

Task 명	설명	입력	출력
Entity 생성	테이블 정의 기반으로 JPA Entity 클래스 생성	Table 구조	@Entity Java Class
Repository 생성	Entity에 대한 JPA Repository 자동 생성	Entity	Repository 인터페이스
Service 생성	기본 CRUD 및 확장 메서드를 포함한 비즈니스 로직 클래스 생성	Repository	Service 클래스
Controller 생성	REST API 방식의 CRUD 컨트롤러 생성	Service	@RestController
Swagger 문서 생성	API 자동 문서화	Controller	openapi.json 문서
HTML 템플릿 생성	Thymeleaf 기반 View 자동 생성	Entity	.html 파일
DDL 생성	Entity 기반으로 Hibernate DDL 생성	Entity	CREATE TABLE 문
GitHub 연동	소스코드 자동 커밋 및 GitHub Push	생성된 소스	Git 커밋 및 Push 로그
Docker 빌드	Spring Boot 기반 Docker 이미지 자동 생성	소스코드	Docker Image (로컬/레지스트리)
Kubernetes 배포	Docker 이미지를 K8s 클러스터에 자동 배포	Docker Image	K8s Deployment 상태
4.	입력 정의서 포맷 예시
본 문서는 전사 EA 표준 사업을 위한 솔루션 표준 프로파일을 도식화하고 상세에 대해 기술한 문서이다.
4.1.	JSON 기반
{
  "tableName": "MBB_USER",
  "tableComment": "사용자 정보 테이블",
  "columns": [
    {
      "columnName": "USER_ID",
      "dataType": "BIGINT",
      "columnSize": null,
      "nullable": false,
      "primaryKey": true,
      "autoIncrement": true,
      "comment": "사용자 고유 ID"
    },
    {
      "columnName": "USER_NAME",
      "dataType": "VARCHAR",
      "columnSize": 100,
      "nullable": false,
      "primaryKey": false,
      "comment": "사용자 이름"
    },
    {
      "columnName": "EMAIL",
      "dataType": "VARCHAR",
      "columnSize": 200,
      "nullable": false,
      "primaryKey": false,
      "comment": "이메일 주소"
    },
    {
      "columnName": "PHONE",
      "dataType": "VARCHAR",
      "columnSize": 20,
      "nullable": true,
      "primaryKey": false,
      "comment": "전화번호"
    },
    {
      "columnName": "BIRTH_DATE",
      "dataType": "DATE",
      "columnSize": null,
      "nullable": true,
      "primaryKey": false,
      "comment": "생년월일"
    },
    {
      "columnName": "CREATED_AT",
      "dataType": "TIMESTAMP",
      "columnSize": null,
      "nullable": false,
      "primaryKey": false,
      "defaultValue": "CURRENT_TIMESTAMP",
      "comment": "생성일시"
    },
    {
      "columnName": "UPDATED_AT",
      "dataType": "TIMESTAMP",
      "columnSize": null,
      "nullable": false,
      "primaryKey": false,
      "defaultValue": "CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP",
      "comment": "수정일시"
    }
  ]
}

4.2.	Excel 기반
컬럼명	타입	PK	필수	설명
id	Long	Y	Y	사용자 ID
username	String		Y	사용자명
email	String		N	이메일 주소
created_at	LocalDateTime		N	생성일
5.	구성 예시
본 문서는 전사 EA 표준 사업을 위한 솔루션 표준 프로파일을 도식화하고 상세에 대해 기술한 문서이다.

•	TaskPipelineRunner.java: 전체 Task 흐름 컨트롤
•	EntityGeneratorTask.java: Entity 생성 로직 포함
•	TemplateEngineHelper.java: FreeMarker/Velocity 연동 템플릿 출력
•	SwaggerAutoGenTask.java: Controller → OpenAPI 연동
•	DDLGenerator.java: Hibernate DDL 역생성 모듈
•	GitHubSyncTask.java: Git 커밋 및 Push 수행
•	DockerBuildTask.java: Dockerfile 빌드 및 이미지 생성
•	KubernetesDeployTask.java: 배포 YAML 실행 및 상태 확인
________________________________________
6.	GitHub / Docker / Kubernetes 연계 아키텍처

[CodeGen 완료]
   ↓
[GitHub Task]
   - Git Add/Commit/Push 자동화
   ↓
[Docker Task]
   - Dockerfile 생성
   - 이미지 빌드 & Docker Hub Push
   ↓
[Kubernetes Task]
   - YAML 생성
   - kubectl apply 자동 실행
6.1.	상세화 설계
단계	절차	주요 화면 기능 구성	관련 스크립트/Task
1단계	코드 생성 완료 후 Git 연동 시작	✅ 생성 소스 목록 확인✅ 커밋 메시지 입력✅ Push 대상 브랜치 선택	GitHubSyncTask.java
2단계	GitHub 저장소 Push 수행	✅ Push 로그 출력✅ 브랜치 머지 요청 자동 수행 옵션	git commit + git push
3단계	Docker 이미지화 절차 진입	✅ Dockerfile 내용 확인✅ 이미지 이름 및 태그 입력✅ Build 옵션 선택 (멀티 스테이지 등)	DockerBuildTask.javabuild.gradle 내 docker 플러그인
4단계	Docker 이미지 빌드 및 레지스트리 Push	✅ 로컬 빌드 결과 확인✅ Docker Hub / Private Registry 선택✅ Push 로그 확인	docker builddocker push
5단계	Kubernetes 배포 YAML 확인	✅ Deployment / Service / ConfigMap 등 구성 확인✅ 클러스터 선택 및 namespace 입력✅ 자동 생성된 YAML 확인	KubernetesDeployTask.java
6단계	K8s 배포 실행	✅ kubectl apply 실행 결과 확인✅ Pod 상태 확인 (READY, STATUS 등)✅ K8s 로그 확인	kubectl apply -f *.yaml
7단계	통합 로그 및 상태 대시보드 제공	✅ Git / Docker / K8s 각 Task별 상태 표시✅ 에러 발생 시 상세 로그 확인 UI 제공	PipelineStatusTracker.java (별도 구현)
6.2.	예상화면 (UI 기획 흐름)
6.2.1.	GitHub 연동
•	📋 코드 생성 요약 화면
•	✏️ 커밋 메시지 입력 필드 + 푸시 대상 브랜치 선택
•	🔘 GitHub Push 버튼 → 결과 로그 출력 패널
6.2.2.	Docker 빌드
•	🔧 Dockerfile 자동 생성 확인 화면
•	📦 이미지명 & 태그 입력, 멀티스테이지 여부 설정
•	▶️ Build 버튼 → 빌드 로그 실시간 출력
6.2.3.	Kubernetes 배포
•	📁 YAML 내용 확인 탭 (Deployment, Service 등)
•	🌐 배포 클러스터 및 namespace 선택
•	🚀 kubectl apply 실행 → Pod 상태 & 로그 확인 탭
6.2.4.	추가 설계 고려사항
항목	확장 가능 내용
GitHub Actions 자동화	Push 후 main 브랜치 기준 자동 Docker Build 및 K8s 배포 워크플로
MCP 기반 Task Status 연계	각 Task 실행 이력 저장 (DB 또는 MongoDB 기반), UI에서 이력 조회
멀티환경 배포 설정	dev, stg, prod 환경 분기 → Kubernetes namespace 자동 분리
Helm 기반 배포 확장	helm install로 배포 흐름 확장 (Chart Generator 포함 가능)

7.	확장 고려사항
•	다국어 지원: 주석 및 템플릿에 i18n 적용
•	요청/응답 DTO 분리: RequestDto, ResponseDto 자동 생성
•	입력/출력 검증: Hibernate Validator 자동 설정
•	보안 적용: Token 기반 인증 필터 자동 생성 (JWT 기반)
•	테스트 자동화: @WebMvcTest, @DataJpaTest 기본 케이스 생성
•	CI/CD 연동: GitHub Actions 또는 Jenkins 연계 고려

## **DDL 설정 과정 예시**

### **1. 입력 데이터 (테이블 정의서)**
```json
{
  "tableName": "MBB_USER",
  "tableComment": "사용자 정보 테이블",
  "columns": [
    {
      "columnName": "USER_ID",
      "dataType": "BIGINT",
      "columnSize": null,
      "nullable": false,
      "primaryKey": true,
      "autoIncrement": true,
      "comment": "사용자 고유 ID"
    },
    {
      "columnName": "USER_NAME",
      "dataType": "VARCHAR",
      "columnSize": 100,
      "nullable": false,
      "primaryKey": false,
      "comment": "사용자 이름"
    },
    {
      "columnName": "EMAIL",
      "dataType": "VARCHAR",
      "columnSize": 200,
      "nullable": false,
      "primaryKey": false,
      "comment": "이메일 주소"
    },
    {
      "columnName": "PHONE",
      "dataType": "VARCHAR",
      "columnSize": 20,
      "nullable": true,
      "primaryKey": false,
      "comment": "전화번호"
    },
    {
      "columnName": "BIRTH_DATE",
      "dataType": "DATE",
      "columnSize": null,
      "nullable": true,
      "primaryKey": false,
      "comment": "생년월일"
    },
    {
      "columnName": "CREATED_AT",
      "dataType": "TIMESTAMP",
      "columnSize": null,
      "nullable": false,
      "primaryKey": false,
      "defaultValue": "CURRENT_TIMESTAMP",
      "comment": "생성일시"
    },
    {
      "columnName": "UPDATED_AT",
      "dataType": "TIMESTAMP",
      "columnSize": null,
      "nullable": false,
      "primaryKey": false,
      "defaultValue": "CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP",
      "comment": "수정일시"
    }
  ]
}
```

### **2. 생성되는 DDL (MySQL 예시)**
```sql
-- ========================================
-- 테이블 생성 DDL
-- ========================================

-- MBB_USER 테이블 생성
CREATE TABLE MBB_USER (
    USER_ID BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '사용자 고유 ID',
    USER_NAME VARCHAR(100) NOT NULL COMMENT '사용자 이름',
    EMAIL VARCHAR(200) NOT NULL COMMENT '이메일 주소',
    PHONE VARCHAR(20) NULL COMMENT '전화번호',
    BIRTH_DATE DATE NULL COMMENT '생년월일',
    CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
    UPDATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='사용자 정보 테이블';

-- ========================================
-- 인덱스 생성
-- ========================================

-- 이메일 유니크 인덱스
CREATE UNIQUE INDEX IDX_MBB_USER_EMAIL ON MBB_USER(EMAIL);

-- 사용자명 인덱스
CREATE INDEX IDX_MBB_USER_NAME ON MBB_USER(USER_NAME);

-- ========================================
-- 제약조건 추가
-- ========================================

-- 이메일 형식 검증 (MySQL 8.0+)
ALTER TABLE MBB_USER 
ADD CONSTRAINT CHK_MBB_USER_EMAIL 
CHECK (EMAIL REGEXP '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- ========================================
-- 뷰 생성 (선택사항)
-- ========================================

-- 활성 사용자 뷰
CREATE VIEW V_ACTIVE_MBB_USER AS
SELECT 
    USER_ID,
    USER_NAME,
    EMAIL,
    PHONE,
    BIRTH_DATE,
    CREATED_AT
FROM MBB_USER
WHERE CREATED_AT >= DATE_SUB(NOW(), INTERVAL 1 YEAR);
```

### **3. 다른 데이터베이스별 DDL 예시**

#### **PostgreSQL**
```sql
-- PostgreSQL용 DDL
CREATE TABLE mbb_user (
    user_id BIGSERIAL PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    email VARCHAR(200) NOT NULL UNIQUE,
    phone VARCHAR(20),
    birth_date DATE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 트리거 함수 생성
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- 트리거 생성
CREATE TRIGGER update_mbb_user_updated_at 
    BEFORE UPDATE ON mbb_user 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

#### **Oracle**
```sql
-- Oracle용 DDL
CREATE TABLE MBB_USER (
    USER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USER_NAME VARCHAR2(100) NOT NULL,
    EMAIL VARCHAR2(200) NOT NULL UNIQUE,
    PHONE VARCHAR2(20),
    BIRTH_DATE DATE,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL
);

-- 시퀀스 생성 (IDENTITY 대신 사용하는 경우)
CREATE SEQUENCE SEQ_MBB_USER_ID
    START WITH 1
    INCREMENT BY 1
    NOCACHE
    NOCYCLE;

-- 트리거 생성
CREATE OR REPLACE TRIGGER TRG_MBB_USER_UPDATED_AT
    BEFORE UPDATE ON MBB_USER
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/
```

### **4. DDL 설정 과정의 주요 기능**

1. **데이터 타입 매핑**
   - Java 타입 → 데이터베이스 타입 변환
   - 예: `String` → `VARCHAR(255)`, `Long` → `BIGINT`

2. **제약조건 생성**
   - Primary Key, Foreign Key, Unique, Not Null
   - Check 제약조건 (이메일 형식, 나이 범위 등)

3. **인덱스 생성**
   - 성능 최적화를 위한 인덱스 자동 생성
   - Unique 인덱스, Composite 인덱스

4. **데이터베이스별 특화 기능**
   - MySQL: AUTO_INCREMENT, ENGINE 설정
   - PostgreSQL: SERIAL, 트리거
   - Oracle: SEQUENCE, 트리거

5. **보안 및 성능 설정**
   - 문자셋 설정 (UTF-8)
   - 파티셔닝 설정
   - 백업/복구 고려사항

### **5. 실제 사용 시나리오**

```java
// DDL 생성 요청
POST /mbb/workflow/ddl/generate
{
  "tableDefinition": {
    "tableName": "MBB_USER",
    "databaseType": "MYSQL",
    "columns": [...]
  }
}

// 응답
{
  "success": true,
  "generatedCode": {
    "ddlCode": "CREATE TABLE MBB_USER (...)",
    "filePath": "./generated/ddl/MBB_USER.sql"
  }
}
```

**이렇게 DDL 설정 과정은 테이블 정의서를 실제 데이터베이스에서 사용할 수 있는 SQL 스키마로 변환하는 중요한 과정입니다!** 🗄️

## **✅ Repository 생성 기능 URL 매핑 수정 완료!**

### **✅ 수정 내용:**

**1. URL 매핑 방식 변경:**
```java
<code_block_to_apply_changes_from>
```

**2. 더 명시적인 URL 매핑:**
- 페이지 접속: `GET /mbb/repository-generator`
- API 호출: `POST /mbb/repository-generator/generate`

### **✅ 해결 방법:**

**1. 애플리케이션 재시작:**
```bash
# 기존 프로세스 종료
taskkill /F /PID 12420

# 애플리케이션 재시작
cd mbb-java && mvn spring-boot:run
```

**2. 테스트:**
- Repository 생성 화면 접속: `http://localhost:8086/mbb/repository-generator`
- 정상 작동 확인

### **✅ 예상 결과:**
- Spring Boot가 Controller를 올바르게 인식
- URL 매핑이 정상적으로 작동
- 404 NOT_FOUND 오류 해결

애플리케이션을 재시작하시면 Repository 생성 기능이 정상적으로 작동할 것입니다! 🚀

