# 🧠 Chain of Thought - 단계별 사고 과정 가이드

## 🎯 코드 생성 시 사고 과정 (Thinking Process)

### 1단계: 요구사항 분석 (Requirement Analysis)
```
사고 과정:
1. 어떤 기능을 구현해야 하는가?
2. 어떤 컴포넌트가 필요한가? (Controller, Service, Repository, DTO)
3. 어떤 패키지에 배치해야 하는가?
4. 어떤 명명 규칙을 적용해야 하는가?
```

### 2단계: 패키지 구조 결정 (Package Structure Decision)
```
사고 과정:
1. 모듈명은 무엇인가? (mbc, mba, ksa, kji)
2. 레이어는 무엇인가? (web, service, repository, config)
3. 구체적 패키지는 무엇인가? (controller, dto, impl, mapper)
4. 최종 패키지 경로: com.skax.eatool.{module}/{layer}/{specific}
```

### 3단계: 클래스 설계 (Class Design)
```
사고 과정:
1. 클래스 타입은 무엇인가? (PC, DC, Service, DTO, Mapper)
2. 어떤 어노테이션이 필요한가? (@RestController, @Service, @Mapper)
3. 의존성은 무엇인가? (Repository, Service, Mapper)
4. 생성자 주입이 필요한가?
```

### 4단계: 메서드 설계 (Method Design)
```
사고 과정:
1. 메서드명은 무엇인가? (camelCase 사용)
2. 매개변수는 무엇인가? (DTO, ID, Pageable)
3. 반환 타입은 무엇인가? (ResponseEntity, DTO, List)
4. 예외 처리가 필요한가?
```

### 5단계: 로깅 설계 (Logging Design)
```
사고 과정:
1. 어떤 로그 레벨을 사용할까? (INFO, DEBUG, ERROR)
2. 어떤 정보를 로그에 포함할까? (ID, 이메일, 상태)
3. 민감한 정보는 마스킹해야 하는가?
4. 로그 메시지는 한글로 작성할까?
```

## 🔄 단계별 구현 가이드 (Step-by-Step Implementation)

### 예시: 사용자 조회 API 구현

#### 1단계: 컨트롤러 설계
```java
// 사고 과정: REST API이므로 DC 접미사, ResponseEntity 사용
@RestController
@RequestMapping("/api/users")
@Slf4j
public class UserApiDC {
    
    private final UserService userService;
    
    public UserApiDC(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
        log.info("사용자 조회 요청: id={}", id);
        UserDto user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
}
```

#### 2단계: 서비스 설계
```java
// 사고 과정: 비즈니스 로직이므로 Service, 예외 처리 필요
@Service
@Transactional(readOnly = true)
@Slf4j
public class UserServiceImpl implements UserService {
    
    private final UserRepository userRepository;
    
    public UserServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Override
    public UserDto getUserById(Long id) {
        log.debug("사용자 조회 시작: id={}", id);
        
        User user = userRepository.findById(id)
            .orElseThrow(() -> {
                log.warn("사용자를 찾을 수 없음: id={}", id);
                return new UserNotFoundException("사용자를 찾을 수 없습니다: " + id);
            });
        
        log.debug("사용자 조회 완료: id={}, email={}", id, user.getEmail());
        return UserDto.from(user);
    }
}
```

#### 3단계: DTO 설계
```java
// 사고 과정: 응답용이므로 Dto 접미사, from 메서드 필요
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserDto {
    private Long id;
    private String email;
    private String name;
    private String role;
    private LocalDateTime createdAt;
    
    public static UserDto from(User user) {
        return UserDto.builder()
            .id(user.getId())
            .email(user.getEmail())
            .name(user.getName())
            .role(user.getRole().name())
            .createdAt(user.getCreatedAt())
            .build();
    }
}
```

#### 4단계: 예외 처리 설계
```java
// 사고 과정: 구체적 예외가 필요하므로 별도 클래스 생성
public class UserNotFoundException extends BusinessException {
    public UserNotFoundException(String message) {
        super(message, "USER_NOT_FOUND");
    }
}
```

## 🎯 사고 과정 체크리스트 (Thinking Process Checklist)

### 요구사항 분석 체크리스트
- [ ] 기능 요구사항이 명확한가?
- [ ] 필요한 컴포넌트가 모두 식별되었는가?
- [ ] 패키지 구조가 올바른가?
- [ ] 명명 규칙이 적용되었는가?

### 설계 체크리스트
- [ ] 클래스 타입이 올바른가? (PC, DC, Service, DTO)
- [ ] 필요한 어노테이션이 모두 포함되었는가?
- [ ] 의존성 주입이 올바른가?
- [ ] 생성자 주입을 사용했는가?

### 구현 체크리스트
- [ ] 메서드명이 camelCase인가?
- [ ] 반환 타입이 적절한가?
- [ ] 예외 처리가 구현되었는가?
- [ ] 로깅이 적절히 구현되었는가?

### 품질 체크리스트
- [ ] Javadoc이 작성되었는가?
- [ ] 한글 주석이 사용되었는가?
- [ ] 들여쓰기가 4칸 스페이스인가?
- [ ] 최대 줄 길이가 120자 이하인가?

## 🚨 사고 과정에서 주의할 점

### 절대 하지 말 것 (NEVER DO)
1. **패키지 구조 무시**: `com.skax.eatool` 외부에 클래스 생성
2. **명명 규칙 무시**: PC, DC, DTO 접미사 생략
3. **어노테이션 생략**: @Service, @RestController 등 누락
4. **예외 처리 무시**: 예외 상황 고려하지 않음
5. **로깅 무시**: 로깅 없이 구현

### 반드시 해야 할 것 (MUST DO)
1. **단계별 사고**: 요구사항 → 설계 → 구현 → 검증
2. **패키지 우선**: 올바른 패키지 구조 결정
3. **명명 규칙 준수**: 컴포넌트별 명명 규칙 적용
4. **예외 처리**: 모든 예외 상황 고려
5. **로깅 구현**: 적절한 로깅 추가

## 📚 참고 문서
- [핵심 규칙](mdc:.cursor/rules/critical-rules.mdc)
- [Spring Boot 패턴](mdc:.cursor/rules/spring-boot-patterns-optimized.mdc)
- [명명 규칙](mdc:.cursor/rules/naming-conventions.mdc)
description:
globs:
alwaysApply: false
---
