# Backend Database Guide

## 🗄️ **SKAX EA Tool Eplaton Database Implementation Rules**

### **🏗️ 데이터베이스 아키텍처 개요**

```
📦 Database Layer Structure
├── 🎯 Repository Layer
│   ├── Data Access Interface
│   ├── Type-Safe Queries
│   ├── Transaction Management
│   └── Error Handling
├── 🔧 Mapper Layer (MyBatis)
│   ├── SQL Mapping
│   ├── Result Mapping
│   └── Dynamic Queries
├── 💾 Entity/DTO Layer
│   ├── Type-Safe Models
│   ├── Data Validation
│   └── Mapping Rules
└── 🎭 Database Configuration
    ├── Connection Pool
    ├── Transaction Manager
    └── MyBatis Configuration
```

### **🎯 MUST FOLLOW - 데이터베이스 구현 규칙**

#### **1. Repository 클래스 구조**

**✅ 올바른 Repository 인터페이스**
```java
/**
 * {도메인} Repository 인터페이스
 * 
 * 프로그램명: {도메인}Repository.java
 * 설명: {도메인} 데이터 접근을 위한 Repository 인터페이스
 * 작성일: 2024-01-01
 * 작성자: SKAX Project Team
 * 
 * 주요 기능:
 * - {도메인} CRUD 작업
 * - 타입 안전한 쿼리 메서드
 * - 페이징 및 정렬 지원
 * 
 * @version 1.0
 */
public interface {도메인}Repository {
    
    /**
     * {도메인} 조회
     * 
     * @param {도메인}DDTO 조회 조건
     * @return {도메인} 정보
     * @throws NewBusinessException 비즈니스 예외
     */
    {도메인} get{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException;
    
    /**
     * {도메인} 목록 조회
     * 
     * @param {도메인}DDTO 조회 조건
     * @return {도메인} 목록
     * @throws NewBusinessException 비즈니스 예외
     */
    List<{도메인}> getList{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException;
    
    /**
     * {도메인} 생성
     * 
     * @param {도메인}DDTO {도메인} 정보
     * @return 생성된 행 수
     * @throws NewBusinessException 비즈니스 예외
     */
    int create{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException;
    
    /**
     * {도메인} 수정
     * 
     * @param {도메인}DDTO {도메인} 정보
     * @return 수정된 행 수
     * @throws NewBusinessException 비즈니스 예외
     */
    int update{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException;
    
    /**
     * {도메인} 삭제
     * 
     * @param {도메인}DDTO {도메인} 정보
     * @return 삭제된 행 수
     * @throws NewBusinessException 비즈니스 예외
     */
    int delete{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException;
    
    /**
     * {도메인} 존재 여부 확인
     * 
     * @param {도메인}DDTO 조회 조건
     * @return 존재 여부
     * @throws NewBusinessException 비즈니스 예외
     */
    boolean exists{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException;
    
    /**
     * {도메인} 개수 조회
     * 
     * @param {도메인}DDTO 조회 조건
     * @return 개수
     * @throws NewBusinessException 비즈니스 예외
     */
    int count{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException;
}
```

#### **2. Repository 구현체**

**✅ 올바른 Repository 구현체**
```java
/**
 * {도메인} MyBatis Repository 구현체
 * 
 * 프로그램명: {도메인}MyBatisRepository.java
 * 설명: MyBatis를 사용한 {도메인} Repository 구현
 * 작성일: 2024-01-01
 * 작성자: SKAX Project Team
 * 
 * 주요 기능:
 * - {도메인} CRUD 작업
 * - 타입 안전한 데이터 접근
 * - 에러 처리 및 로깅
 * 
 * @version 1.0
 */
@Repository
@Profile("mybatis")
public class {도메인}MyBatisRepository implements {도메인}Repository {
    
    private NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    private static final Logger slf4jLogger = LoggerFactory.getLogger({도메인}MyBatisRepository.class);
    
    @Autowired
    private {도메인}Mapper {도메인}Mapper;
    
    @Override
    public List<{도메인}> getList{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException {
        logger.info("{도메인}MyBatisRepository", "=== {도메인}MyBatisRepository.getList{도메인} START ===");
        slf4jLogger.info("=== {도메인}MyBatisRepository.getList{도메인} START (SLF4J) ===");
        
        try {
            // 타입 안전성 검증
            validate{도메인}DDTO({도메인}DDTO);
            
            // Mapper 호출
            List<{도메인}> {도메인}List = {도메인}Mapper.findBySearchCondition({도메인}DDTO);
            
            // 결과 검증
            validateResult({도메인}List);
            
            logger.info("{도메인}MyBatisRepository", "=== {도메인}MyBatisRepository.getList{도메인} END ===");
            slf4jLogger.info("=== {도메인}MyBatisRepository.getList{도메인} END (SLF4J) ===");
            
            return {도메인}List;
            
        } catch (Exception e) {
            logger.error("Error in getList{도메인}: " + e.getMessage(), String.valueOf(e));
            slf4jLogger.error("Error in getList{도메인}: " + e.getMessage(), e);
            throw new NewBusinessException("B0000001", "getList{도메인}", e);
        }
    }
    
    @Override
    public int create{도메인}({도메인}DDTO {도메인}DDTO) throws NewBusinessException {
        logger.info("{도메인}MyBatisRepository", "=== {도메인}MyBatisRepository.create{도메인} START ===");
        
        try {
            // 타입 안전성 검증
            validateCreate{도메인}DDTO({도메인}DDTO);
            
            // Mapper 호출
            int result = {도메인}Mapper.insert{도메인}({도메인}DDTO);
            
            // 결과 검증
            validateCreateResult(result);
            
            logger.info("{도메인}MyBatisRepository", "=== {도메인}MyBatisRepository.create{도메인} END ===");
            return result;
            
        } catch (Exception e) {
            logger.error("Error in create{도메인}: " + e.getMessage(), String.valueOf(e));
            throw new NewBusinessException("B0000002", "create{도메인}", e);
        }
    }
    
    /**
     * DTO 타입 안전성 검증
     */
    private void validate{도메인}DDTO({도메인}DDTO {도메인}DDTO) throws NewBusinessException {
        if ({도메인}DDTO == null) {
            throw new NewBusinessException("DTO는 null일 수 없습니다.");
        }
        
        // 필수 필드 검증
        if (StringUtils.isEmpty({도메인}DDTO.get{도메인}Id())) {
            throw new NewBusinessException("{도메인} ID는 필수입니다.");
        }
    }
    
    /**
     * 생성 결과 검증
     */
    private void validateCreateResult(int result) throws NewBusinessException {
        if (result <= 0) {
            throw new NewBusinessException("{도메인} 생성에 실패했습니다.");
        }
    }
}
```

#### **3. 타입 안전한 Entity/DTO 구조**

**✅ 올바른 Entity 클래스**
```java
/**
 * {도메인} 엔티티 클래스
 * 
 * 프로그램명: {도메인}Entity.java
 * 설명: {도메인} 데이터베이스 엔티티
 * 작성일: 2024-01-01
 * 작성자: SKAX Project Team
 * 
 * 주요 기능:
 * - 타입 안전한 데이터 모델
 * - 데이터베이스 매핑
 * - 검증 규칙 적용
 * 
 * @version 1.0
 */
@Entity
@Table(name = "{도메인_소문자}s")
public class {도메인}Entity extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "{도메인_소문자}_id")
    private Long {도메인}Id;
    
    @Column(name = "{도메인_소문자}_name", nullable = false, length = 100)
    @NotBlank(message = "{도메인}명은 필수입니다.")
    private String {도메인}Name;
    
    @Column(name = "status", nullable = false, length = 20)
    @Enumerated(EnumType.STRING)
    private {도메인}Status status = {도메인}Status.ACTIVE;
    
    @Column(name = "created_date", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdDate;
    
    @Column(name = "modified_date", nullable = false)
    @UpdateTimestamp
    private LocalDateTime modifiedDate;
    
    // 기본 생성자
    public {도메인}Entity() {}
    
    // 생성자
    public {도메인}Entity(String {도메인}Name) {
        this.{도메인}Name = {도메인}Name;
        this.status = {도메인}Status.ACTIVE;
    }
    
    // Getter와 Setter
    public Long get{도메인}Id() {
        return {도메인}Id;
    }
    
    public void set{도메인}Id(Long {도메인}Id) {
        this.{도메인}Id = {도메인}Id;
    }
    
    public String get{도메인}Name() {
        return {도메인}Name;
    }
    
    public void set{도메인}Name(String {도메인}Name) {
        this.{도메인}Name = {도메인}Name;
    }
    
    public {도메인}Status getStatus() {
        return status;
    }
    
    public void setStatus({도메인}Status status) {
        this.status = status;
    }
    
    /**
     * {도메인} 상태 열거형
     */
    public enum {도메인}Status {
        ACTIVE, INACTIVE, SUSPENDED, DELETED
    }
    
    /**
     * 타입 안전한 상태 변경
     */
    public void activate() {
        this.status = {도메인}Status.ACTIVE;
    }
    
    public void deactivate() {
        this.status = {도메인}Status.INACTIVE;
    }
    
    public void suspend() {
        this.status = {도메인}Status.SUSPENDED;
    }
    
    public void delete() {
        this.status = {도메인}Status.DELETED;
    }
    
    /**
     * 타입 안전한 상태 확인
     */
    public boolean isActive() {
        return {도메인}Status.ACTIVE.equals(this.status);
    }
    
    public boolean isInactive() {
        return {도메인}Status.INACTIVE.equals(this.status);
    }
    
    public boolean isSuspended() {
        return {도메인}Status.SUSPENDED.equals(this.status);
    }
    
    public boolean isDeleted() {
        return {도메인}Status.DELETED.equals(this.status);
    }
}
```

#### **4. 타입 안전한 DTO 클래스**

**✅ 올바른 DTO 클래스**
```java
/**
 * {도메인} DTO 클래스
 * 
 * 프로그램명: {도메인}DDTO.java
 * 설명: {도메인} 데이터 전송 객체
 * 작성일: 2024-01-01
 * 작성자: SKAX Project Team
 * 
 * 주요 기능:
 * - 타입 안전한 데이터 전송
 * - 검증 규칙 적용
 * - Entity와의 매핑
 * 
 * @version 1.0
 */
public class {도메인}DDTO extends NewAbstractDTO {
    
    // 타입 안전한 필드 정의
    private String {도메인}Id;
    private String {도메인}Name;
    private String status;
    private String createdDate;
    private String modifiedDate;
    
    // 검증 규칙
    @NotBlank(message = "{도메인} ID는 필수입니다.")
    private String validation{도메인}Id;
    
    @NotBlank(message = "{도메인}명은 필수입니다.")
    @Size(min = 1, max = 100, message = "{도메인}명은 1-100자 사이여야 합니다.")
    private String validation{도메인}Name;
    
    // 기본 생성자
    public {도메인}DDTO() {}
    
    // 생성자
    public {도메인}DDTO(String {도메인}Id, String {도메인}Name) {
        this.{도메인}Id = {도메인}Id;
        this.{도메인}Name = {도메인}Name;
        this.status = "ACTIVE";
    }
    
    // Getter와 Setter
    public String get{도메인}Id() {
        return {도메인}Id;
    }
    
    public void set{도메인}Id(String {도메인}Id) {
        this.{도메인}Id = {도메인}Id;
        this.validation{도메인}Id = {도메인}Id; // 검증용 필드 동기화
    }
    
    public String get{도메인}Name() {
        return {도메인}Name;
    }
    
    public void set{도메인}Name(String {도메인}Name) {
        this.{도메인}Name = {도메인}Name;
        this.validation{도메인}Name = {도메인}Name; // 검증용 필드 동기화
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    public String getCreatedDate() {
        return createdDate;
    }
    
    public void setCreatedDate(String createdDate) {
        this.createdDate = createdDate;
    }
    
    public String getModifiedDate() {
        return modifiedDate;
    }
    
    public void setModifiedDate(String modifiedDate) {
        this.modifiedDate = modifiedDate;
    }
    
    /**
     * 타입 안전한 상태 설정
     */
    public void setActiveStatus() {
        this.status = "ACTIVE";
    }
    
    public void setInactiveStatus() {
        this.status = "INACTIVE";
    }
    
    public void setSuspendedStatus() {
        this.status = "SUSPENDED";
    }
    
    public void setDeletedStatus() {
        this.status = "DELETED";
    }
    
    /**
     * 타입 안전한 상태 확인
     */
    public boolean isActive() {
        return "ACTIVE".equals(this.status);
    }
    
    public boolean isInactive() {
        return "INACTIVE".equals(this.status);
    }
    
    public boolean isSuspended() {
        return "SUSPENDED".equals(this.status);
    }
    
    public boolean isDeleted() {
        return "DELETED".equals(this.status);
    }
    
    /**
     * 타입 안전한 검증
     */
    public void validate() throws NewBusinessException {
        if (StringUtils.isEmpty({도메인}Id)) {
            throw new NewBusinessException("{도메인} ID는 필수입니다.");
        }
        
        if (StringUtils.isEmpty({도메인}Name)) {
            throw new NewBusinessException("{도메인}명은 필수입니다.");
        }
        
        if ({도메인}Name.length() > 100) {
            throw new NewBusinessException("{도메인}명은 100자를 초과할 수 없습니다.");
        }
    }
}
```

#### **5. MyBatis Mapper 인터페이스**

**✅ 올바른 Mapper 인터페이스**
```java
/**
 * {도메인} MyBatis Mapper 인터페이스
 * 
 * 프로그램명: {도메인}Mapper.java
 * 설명: {도메인} 데이터베이스 매핑을 위한 MyBatis Mapper
 * 작성일: 2024-01-01
 * 작성자: SKAX Project Team
 * 
 * 주요 기능:
 * - 타입 안전한 SQL 매핑
 * - 동적 쿼리 지원
 * - 결과 매핑
 * 
 * @version 1.0
 */
@Mapper
public interface {도메인}Mapper {
    
    /**
     * 검색 조건으로 {도메인} 목록 조회
     * 
     * @param {도메인}DDTO 조회 조건
     * @return {도메인} 목록
     */
    List<{도메인}> findBySearchCondition({도메인}DDTO {도메인}DDTO);
    
    /**
     * {도메인} ID로 조회
     * 
     * @param {도메인}Id {도메인} ID
     * @return {도메인} 정보
     */
    {도메인} findBy{도메인}Id(String {도메인}Id);
    
    /**
     * {도메인} 생성
     * 
     * @param {도메인}DDTO {도메인} 정보
     * @return 생성된 행 수
     */
    int insert{도메인}({도메인}DDTO {도메인}DDTO);
    
    /**
     * {도메인} 수정
     * 
     * @param {도메인}DDTO {도메인} 정보
     * @return 수정된 행 수
     */
    int update{도메인}({도메인}DDTO {도메인}DDTO);
    
    /**
     * {도메인} 삭제
     * 
     * @param {도메인}DDTO {도메인} 정보
     * @return 삭제된 행 수
     */
    int delete{도메인}({도메인}DDTO {도메인}DDTO);
    
    /**
     * {도메인} 존재 여부 확인
     * 
     * @param {도메인}Id {도메인} ID
     * @return 존재 여부
     */
    boolean existsBy{도메인}Id(String {도메인}Id);
    
    /**
     * {도메인} 개수 조회
     * 
     * @param {도메인}DDTO 조회 조건
     * @return 개수
     */
    int countBySearchCondition({도메인}DDTO {도메인}DDTO);
}
```

#### **6. MyBatis XML Mapper**

**✅ 올바른 XML Mapper**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.skax.eatool.mbc.dc.{도메인_소문자}dc.mapper.{도메인}Mapper">

    <!-- 결과 맵 정의 -->
    <resultMap id="{도메인}ResultMap" type="com.skax.eatool.mbc.dc.{도메인_소문자}dc.dto.{도메인}Dto">
        <id column="{도메인_대문자}_ID" property="{도메인}Id" jdbcType="VARCHAR"/>
        <result column="{도메인_대문자}_NAME" property="{도메인}Name" jdbcType="VARCHAR"/>
        <result column="STATUS" property="status" jdbcType="VARCHAR"/>
        <result column="CREATED_DATE" property="createdDate" jdbcType="TIMESTAMP"/>
        <result column="MODIFIED_DATE" property="modifiedDate" jdbcType="TIMESTAMP"/>
    </resultMap>

    <!-- {도메인} 목록 조회 -->
    <select id="findBySearchCondition" resultMap="{도메인}ResultMap" 
            parameterType="com.skax.eatool.mbc.dc.{도메인_소문자}dc.dto.{도메인}DDTO">
        SELECT 
            {도메인_대문자}_ID,
            {도메인_대문자}_NAME,
            STATUS,
            CREATED_DATE,
            MODIFIED_DATE
        FROM {도메인_대문자}_INFO
        <where>
            <if test="{도메인}Id != null and {도메인}Id != ''">
                AND {도메인_대문자}_ID = #{({도메인}Id)}
            </if>
            <if test="{도메인}Name != null and {도메인}Name != ''">
                AND {도메인_대문자}_NAME LIKE CONCAT('%', #{({도메인}Name)}, '%')
            </if>
            <if test="status != null and status != ''">
                AND STATUS = #{status}
            </if>
        </where>
        ORDER BY CREATED_DATE DESC
        <if test="pageSize != null and pageSize > 0">
            LIMIT #{pageSize} OFFSET #{offset}
        </if>
    </select>

    <!-- {도메인} ID로 조회 -->
    <select id="findBy{도메인}Id" resultMap="{도메인}ResultMap" parameterType="string">
        SELECT 
            {도메인_대문자}_ID,
            {도메인_대문자}_NAME,
            STATUS,
            CREATED_DATE,
            MODIFIED_DATE
        FROM {도메인_대문자}_INFO
        WHERE {도메인_대문자}_ID = #{({도메인}Id)}
    </select>

    <!-- {도메인} 생성 -->
    <insert id="insert{도메인}" parameterType="com.skax.eatool.mbc.dc.{도메인_소문자}dc.dto.{도메인}DDTO">
        INSERT INTO {도메인_대문자}_INFO (
            {도메인_대문자}_ID,
            {도메인_대문자}_NAME,
            STATUS,
            CREATED_DATE,
            MODIFIED_DATE
        ) VALUES (
            #{({도메인}Id)},
            #{({도메인}Name)},
            #{status},
            NOW(),
            NOW()
        )
    </insert>

    <!-- {도메인} 수정 -->
    <update id="update{도메인}" parameterType="com.skax.eatool.mbc.dc.{도메인_소문자}dc.dto.{도메인}DDTO">
        UPDATE {도메인_대문자}_INFO
        SET 
            {도메인_대문자}_NAME = #{({도메인}Name)},
            STATUS = #{status},
            MODIFIED_DATE = NOW()
        WHERE {도메인_대문자}_ID = #{({도메인}Id)}
    </update>

    <!-- {도메인} 삭제 -->
    <delete id="delete{도메인}" parameterType="com.skax.eatool.mbc.dc.{도메인_소문자}dc.dto.{도메인}DDTO">
        DELETE FROM {도메인_대문자}_INFO
        WHERE {도메인_대문자}_ID = #{({도메인}Id)}
    </delete>

    <!-- {도메인} 존재 여부 확인 -->
    <select id="existsBy{도메인}Id" resultType="boolean" parameterType="string">
        SELECT COUNT(1) > 0
        FROM {도메인_대문자}_INFO
        WHERE {도메인_대문자}_ID = #{({도메인}Id)}
    </select>

    <!-- {도메인} 개수 조회 -->
    <select id="countBySearchCondition" resultType="int" 
            parameterType="com.skax.eatool.mbc.dc.{도메인_소문자}dc.dto.{도메인}DDTO">
        SELECT COUNT(1)
        FROM {도메인_대문자}_INFO
        <where>
            <if test="{도메인}Id != null and {도메인}Id != ''">
                AND {도메인_대문자}_ID = #{({도메인}Id)}
            </if>
            <if test="{도메인}Name != null and {도메인}Name != ''">
                AND {도메인_대문자}_NAME LIKE CONCAT('%', #{({도메인}Name)}, '%')
            </if>
            <if test="status != null and status != ''">
                AND STATUS = #{status}
            </if>
        </where>
    </select>

</mapper>
```

### **🚫 NEVER DO - 데이터베이스 위반사항**

#### **1. 잘못된 타입 사용**
```java
// ❌ 잘못된 예시
public class UserRepository {
    
    // Object 타입 사용 (타입 안전성 없음)
    public Object getUser(Object userId) {
        return jdbcTemplate.queryForObject("SELECT * FROM users WHERE id = ?", userId);
    }
    
    // Map 사용 (타입 안전성 없음)
    public Map<String, Object> getUserMap(String userId) {
        return jdbcTemplate.queryForMap("SELECT * FROM users WHERE id = ?", userId);
    }
}

// ✅ 올바른 예시
public interface UserRepository {
    
    // 타입 안전한 메서드
    User getUser(UserDDTO userDDTO) throws NewBusinessException;
    
    List<User> getListUser(UserDDTO userDDTO) throws NewBusinessException;
    
    int createUser(UserDDTO userDDTO) throws NewBusinessException;
}
```

#### **2. 잘못된 DTO 구조**
```java
// ❌ 잘못된 예시
public class UserDDTO {
    
    // 모든 필드가 String (타입 안전성 없음)
    private String userId;
    private String userName;
    private String age; // 숫자여야 함
    private String isActive; // boolean이어야 함
    private String createdDate; // Date여야 함
}

// ✅ 올바른 예시
public class UserDDTO extends NewAbstractDTO {
    
    // 적절한 타입 사용
    private String userId;
    private String userName;
    private Integer age;
    private Boolean isActive;
    private String createdDate;
    
    // 타입 안전한 메서드
    public void setActiveStatus() {
        this.isActive = true;
    }
    
    public boolean isActive() {
        return Boolean.TRUE.equals(this.isActive);
    }
}
```

#### **3. 잘못된 SQL 매핑**
```xml
<!-- ❌ 잘못된 예시 -->
<select id="getUser" resultType="map">
    SELECT * FROM users WHERE id = #{id}
</select>

<!-- ✅ 올바른 예시 -->
<select id="findByUserId" resultMap="UserResultMap" parameterType="string">
    SELECT 
        USER_ID,
        USER_NAME,
        EMAIL,
        STATUS,
        CREATED_DATE
    FROM USER_INFO
    WHERE USER_ID = #{userId}
</select>
```

### **📋 데이터베이스 구현 체크리스트**

#### **새로운 Repository 생성 시**
- [ ] Repository 인터페이스 정의
- [ ] 타입 안전한 메서드 시그니처
- [ ] 예외 처리 규칙 적용
- [ ] 로깅 구현

#### **타입 안전성 규칙**
- [ ] Object 타입 사용 금지
- [ ] 적절한 Java 타입 사용
- [ ] Enum 사용 (상태값)
- [ ] 검증 규칙 적용

#### **MyBatis 매핑**
- [ ] ResultMap 정의
- [ ] 타입 별칭 설정
- [ ] 동적 쿼리 사용
- [ ] SQL 인젝션 방지

#### **Entity/DTO 구조**
- [ ] 타입 안전한 필드 정의
- [ ] 검증 어노테이션 사용
- [ ] Getter/Setter 구현
- [ ] 상태 관리 메서드

### **🔧 특별한 데이터베이스 패턴**

#### **1. 페이징 처리**
```java
/**
 * 페이징 처리 Repository
 */
public interface PagingRepository<T> {
    
    /**
     * 페이징 조회
     */
    Page<T> findByPage(Pageable pageable);
    
    /**
     * 조건부 페이징 조회
     */
    Page<T> findByConditionWithPage(SearchCondition condition, Pageable pageable);
}
```

#### **2. 배치 처리**
```java
/**
 * 배치 처리 Repository
 */
public interface BatchRepository<T> {
    
    /**
     * 배치 삽입
     */
    int batchInsert(List<T> entities);
    
    /**
     * 배치 수정
     */
    int batchUpdate(List<T> entities);
    
    /**
     * 배치 삭제
     */
    int batchDelete(List<String> ids);
}
```

#### **3. 트랜잭션 관리**
```java
/**
 * 트랜잭션 관리 Repository
 */
@Repository
@Transactional
public class TransactionalRepository {
    
    @Transactional(readOnly = true)
    public List<User> findUsers() {
        // 읽기 전용 트랜잭션
    }
    
    @Transactional
    public void createUser(User user) {
        // 쓰기 트랜잭션
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void complexOperation() {
        // 복잡한 트랜잭션
    }
}
```

### **⚠️ 주의사항**

1. **타입 안전성**: Object 타입 사용 금지, 적절한 Java 타입 사용
2. **SQL 인젝션 방지**: PreparedStatement 사용, 파라미터 바인딩
3. **트랜잭션 관리**: 적절한 트랜잭션 경계 설정
4. **성능 최적화**: 인덱스 활용, 쿼리 최적화
5. **에러 처리**: 모든 데이터베이스 작업에서 예외 처리
6. **로깅**: 모든 데이터베이스 작업에서 상세한 로깅

이 가이드를 따라 데이터베이스 레이어를 구현하면 타입 안전하고 유지보수하기