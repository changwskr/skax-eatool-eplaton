# Backend Business Logic Guide

## 🏢 **SKAX EA Tool Eplaton Business Logic Implementation Rules**

### **🏗️ 비즈니스 로직 아키텍처 개요**

```
📦 Business Logic Layer Structure
├── 🎯 AS (Application Service) Layer
│   ├── Business Logic Orchestration
│   ├── Transaction Management
│   ├── Service Coordination
│   └── Data Validation
├── 🔧 PC (Presentation Control) Layer
│   ├── Data Transformation
│   ├── Business Rules
│   └── Domain Logic
├── 💾 DC (Data Control) Layer
│   ├── Data Access Logic
│   ├── Repository Operations
│   └── Database Transactions
└── 🎭 EPlaton Framework
    ├── TCF (Transaction Control Framework)
    ├── BizAction (Business Action)
    └── BizDelegate (Business Delegate)
```

### **🎯 MUST FOLLOW - 비즈니스 로직 구현 규칙**

#### **1. Application Service (AS) 클래스 구조**

**✅ 올바른 AS 클래스 구조**
```java
/**
 * {도메인} 관리 Application Service
 * 
 * 프로그램명: AS{모듈}{기능번호}.java
 * 설명: {도메인} 관리 애플리케이션 서비스
 * 작성일: 2024-01-01
 * 작성자: SKAX Project Team
 * 
 * 주요 기능:
 * - {도메인} CRUD 비즈니스 로직
 * - AC와 PC 간의 데이터 전달
 * - 트랜잭션 관리
 * - 에러 처리 및 로깅
 * 
 * @version 1.0
 */
@Service
@Transactional
public class AS{모듈}{기능번호} implements NewIApplicationService {
    
    private static final NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    
    @Autowired
    private PC{도메인} pc{도메인};
    
    @Autowired
    private DC{도메인} dc{도메인};
    
    /**
     * 애플리케이션 서비스 실행
     * 
     * @param reqData 요청 데이터
     * @return 응답 데이터
     * @throws NewBusinessException 비즈니스 예외
     */
    @Override
    public NewKBData execute(NewKBData reqData) throws NewBusinessException {
        logger.info("=== AS{모듈}{기능번호}.execute START ===", "AS{모듈}{기능번호}");
        
        try {
            // 1. 입력 데이터 검증
            validateInputData(reqData);
            
            // 2. 명령어 추출
            String command = extractCommand(reqData);
            
            // 3. 명령어별 비즈니스 로직 실행
            NewKBData result = processCommand(command, reqData);
            
            logger.info("=== AS{모듈}{기능번호}.execute END ===", "AS{모듈}{기능번호}");
            return result;
            
        } catch (Exception e) {
            logger.error("=== AS{모듈}{기능번호}.execute - Error: {} ===", e.getMessage(), "AS{모듈}{기능번호}");
            throw new NewBusinessException("비즈니스 로직 실행 중 오류가 발생했습니다. 원인: " + e.getMessage());
        }
    }
    
    /**
     * 명령어별 처리 분기
     */
    private NewKBData processCommand(String command, NewKBData reqData) 
        throws NewBusinessException {
        
        switch (command.toUpperCase()) {
            case "CREATE":
                return processCreate(reqData);
            case "READ":
                return processRead(reqData);
            case "UPDATE":
                return processUpdate(reqData);
            case "DELETE":
                return processDelete(reqData);
            case "LIST":
                return processList(reqData);
            default:
                throw new NewBusinessException("지원하지 않는 명령어입니다: " + command);
        }
    }
}
```

#### **2. 의존성 주입 패턴**

**✅ 올바른 의존성 주입**
```java
@Service
@Transactional
public class AS{모듈}{기능번호} implements NewIApplicationService {
    
    // 1. 로거 의존성
    private static final NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    
    // 2. PC 레이어 의존성 (Presentation Control)
    @Autowired
    private PC{도메인} pc{도메인};
    
    // 3. DC 레이어 의존성 (Data Control)
    @Autowired
    private DC{도메인} dc{도메인};
    
    // 4. 유틸리티 의존성
    @Autowired
    private ValidationUtil validationUtil;
    
    // 5. 외부 서비스 의존성
    @Autowired
    private ExternalService externalService;
    
    // 6. 설정 의존성
    @Value("${app.feature.enabled:false}")
    private boolean featureEnabled;
}
```

#### **3. 트랜잭션 관리**

**✅ 트랜잭션 어노테이션 사용**
```java
@Service
@Transactional
public class AS{모듈}{기능번호} implements NewIApplicationService {
    
    /**
     * 읽기 전용 트랜잭션
     */
    @Transactional(readOnly = true)
    public NewKBData processRead(NewKBData reqData) throws NewBusinessException {
        // 읽기 전용 비즈니스 로직
        return pc{도메인}.read(reqData);
    }
    
    /**
     * 쓰기 트랜잭션
     */
    @Transactional
    public NewKBData processCreate(NewKBData reqData) throws NewBusinessException {
        // 쓰기 비즈니스 로직
        return pc{도메인}.create(reqData);
    }
    
    /**
     * 복잡한 트랜잭션
     */
    @Transactional(rollbackFor = {NewBusinessException.class, Exception.class})
    public NewKBData processComplexBusiness(NewKBData reqData) throws NewBusinessException {
        try {
            // 1. 데이터 검증
            validateData(reqData);
            
            // 2. 비즈니스 로직 실행
            NewKBData result = executeBusinessLogic(reqData);
            
            // 3. 결과 검증
            validateResult(result);
            
            return result;
            
        } catch (Exception e) {
            logger.error("복잡한 비즈니스 로직 실행 실패: {}", e.getMessage());
            throw new NewBusinessException("비즈니스 로직 실행 중 오류가 발생했습니다.");
        }
    }
}
```

#### **4. EPlaton Framework 통합**

**✅ EPlaton BizAction 구조**
```java
/**
 * EPlaton 비즈니스 액션 구현
 */
@Component
public abstract class EPlatonBizAction {
    
    private static final Logger logger = LoggerFactory.getLogger(EPlatonBizAction.class);
    
    @Autowired
    protected TCF tcf;
    
    /**
     * 트랜잭션 제어와 함께 비즈니스 액션 실행
     */
    public EPlatonEvent execute(EPlatonEvent event) {
        String transactionId = generateTransactionId();
        
        try {
            logger.info("비즈니스 액션 시작: {} - 트랜잭션: {}", 
                getClass().getSimpleName(), transactionId);
            
            // 1. 사전 처리
            preAct(event);
            
            // 2. 메인 액션 실행
            EPlatonEvent result = act(event);
            
            // 3. 사후 처리
            postAct(result);
            
            logger.info("비즈니스 액션 완료: {} - 트랜잭션: {}", 
                getClass().getSimpleName(), transactionId);
            
            return result;
            
        } catch (Exception e) {
            logger.error("비즈니스 액션 실패: {} - 트랜잭션: {}", 
                getClass().getSimpleName(), transactionId, e);
            
            // 에러 정보 설정
            setErrorInfo(event, "EACT001", "비즈니스 액션 실행 실패: " + e.getMessage());
            
            throw new RuntimeException("비즈니스 액션 실행 실패", e);
        }
    }
    
    /**
     * 사전 처리 훅
     */
    protected void preAct(EPlatonEvent event) {
        logger.debug("사전 처리: {}", getClass().getSimpleName());
    }
    
    /**
     * 메인 액션 실행 - 하위 클래스에서 구현
     */
    protected abstract EPlatonEvent act(EPlatonEvent event);
    
    /**
     * 사후 처리 훅
     */
    protected void postAct(EPlatonEvent event) {
        logger.debug("사후 처리: {}", getClass().getSimpleName());
    }
    
    /**
     * 에러 정보 설정
     */
    protected void setErrorInfo(EPlatonEvent event, String errorCode, String errorMessage) {
        TPSVCINFODTO tpsvcinfo = event.getTPSVCINFODTO();
        String currentErrorCode = tpsvcinfo.getErrorcode();
        
        if (currentErrorCode != null && currentErrorCode.startsWith("I")) {
            tpsvcinfo.setErrorcode(errorCode);
            tpsvcinfo.setError_message(errorMessage);
        } else if (currentErrorCode != null && currentErrorCode.startsWith("E")) {
            String combinedErrorCode = errorCode + "|" + currentErrorCode;
            tpsvcinfo.setErrorcode(combinedErrorCode);
            tpsvcinfo.setError_message(errorMessage);
        } else {
            tpsvcinfo.setErrorcode(errorCode);
            tpsvcinfo.setError_message(errorMessage);
        }
    }
}
```

#### **5. 비즈니스 로직 구현 패턴**

**✅ CRUD 비즈니스 로직**
```java
@Service
@Transactional
public class AS{모듈}{기능번호} implements NewIApplicationService {
    
    /**
     * 생성 비즈니스 로직
     */
    private NewKBData processCreate(NewKBData reqData) throws NewBusinessException {
        logger.info("=== AS{모듈}{기능번호}.processCreate START ===", "AS{모듈}{기능번호}");
        
        try {
            // 1. 입력 데이터 추출
            {도메인}PDTO {도메인}PDTO = extract{도메인}PDTO(reqData);
            
            // 2. 비즈니스 규칙 검증
            validateBusinessRules({도메인}PDTO);
            
            // 3. PC 레이어 호출
            NewKBData result = pc{도메인}.create({도메인}PDTO);
            
            // 4. 결과 검증
            validateResult(result);
            
            logger.info("=== AS{모듈}{기능번호}.processCreate END ===", "AS{모듈}{기능번호}");
            return result;
            
        } catch (Exception e) {
            logger.error("=== AS{모듈}{기능번호}.processCreate - Error: {} ===", e.getMessage(), "AS{모듈}{기능번호}");
            throw new NewBusinessException("생성 처리 중 오류가 발생했습니다. 원인: " + e.getMessage());
        }
    }
    
    /**
     * 조회 비즈니스 로직
     */
    @Transactional(readOnly = true)
    private NewKBData processRead(NewKBData reqData) throws NewBusinessException {
        logger.info("=== AS{모듈}{기능번호}.processRead START ===", "AS{모듈}{기능번호}");
        
        try {
            // 1. 조회 조건 추출
            String id = extractId(reqData);
            
            // 2. PC 레이어 호출
            NewKBData result = pc{도메인}.read(id);
            
            // 3. 결과 검증
            validateReadResult(result);
            
            logger.info("=== AS{모듈}{기능번호}.processRead END ===", "AS{모듈}{기능번호}");
            return result;
            
        } catch (Exception e) {
            logger.error("=== AS{모듈}{기능번호}.processRead - Error: {} ===", e.getMessage(), "AS{모듈}{기능번호}");
            throw new NewBusinessException("조회 처리 중 오류가 발생했습니다. 원인: " + e.getMessage());
        }
    }
    
    /**
     * 수정 비즈니스 로직
     */
    private NewKBData processUpdate(NewKBData reqData) throws NewBusinessException {
        logger.info("=== AS{모듈}{기능번호}.processUpdate START ===", "AS{모듈}{기능번호}");
        
        try {
            // 1. 입력 데이터 추출
            {도메인}PDTO {도메인}PDTO = extract{도메인}PDTO(reqData);
            
            // 2. 기존 데이터 존재 확인
            validateExistingData({도메인}PDTO);
            
            // 3. 비즈니스 규칙 검증
            validateUpdateRules({도메인}PDTO);
            
            // 4. PC 레이어 호출
            NewKBData result = pc{도메인}.update({도메인}PDTO);
            
            logger.info("=== AS{모듈}{기능번호}.processUpdate END ===", "AS{모듈}{기능번호}");
            return result;
            
        } catch (Exception e) {
            logger.error("=== AS{모듈}{기능번호}.processUpdate - Error: {} ===", e.getMessage(), "AS{모듈}{기능번호}");
            throw new NewBusinessException("수정 처리 중 오류가 발생했습니다. 원인: " + e.getMessage());
        }
    }
    
    /**
     * 삭제 비즈니스 로직
     */
    private NewKBData processDelete(NewKBData reqData) throws NewBusinessException {
        logger.info("=== AS{모듈}{기능번호}.processDelete START ===", "AS{모듈}{기능번호}");
        
        try {
            // 1. 삭제 조건 추출
            String id = extractId(reqData);
            
            // 2. 삭제 가능성 검증
            validateDeletePossibility(id);
            
            // 3. PC 레이어 호출
            NewKBData result = pc{도메인}.delete(id);
            
            logger.info("=== AS{모듈}{기능번호}.processDelete END ===", "AS{모듈}{기능번호}");
            return result;
            
        } catch (Exception e) {
            logger.error("=== AS{모듈}{기능번호}.processDelete - Error: {} ===", e.getMessage(), "AS{모듈}{기능번호}");
            throw new NewBusinessException("삭제 처리 중 오류가 발생했습니다. 원인: " + e.getMessage());
        }
    }
    
    /**
     * 목록 조회 비즈니스 로직
     */
    @Transactional(readOnly = true)
    private NewKBData processList(NewKBData reqData) throws NewBusinessException {
        logger.info("=== AS{모듈}{기능번호}.processList START ===", "AS{모듈}{기능번호}");
        
        try {
            // 1. 조회 조건 추출
            Map<String, Object> searchConditions = extractSearchConditions(reqData);
            
            // 2. PC 레이어 호출
            NewKBData result = pc{도메인}.list(searchConditions);
            
            logger.info("=== AS{모듈}{기능번호}.processList END ===", "AS{모듈}{기능번호}");
            return result;
            
        } catch (Exception e) {
            logger.error("=== AS{모듈}{기능번호}.processList - Error: {} ===", e.getMessage(), "AS{모듈}{기능번호}");
            throw new NewBusinessException("목록 조회 처리 중 오류가 발생했습니다. 원인: " + e.getMessage());
        }
    }
}
```

### **🚫 NEVER DO - 비즈니스 로직 위반사항**

#### **1. 잘못된 의존성 주입**
```java
// ❌ 잘못된 예시
@Service
public class AccountService {
    
    // 직접 Repository 의존 (AS 레이어에서 DC 레이어 직접 의존)
    @Autowired
    private AccountRepository accountRepository;
    
    // 직접 Entity 사용
    public Account createAccount(Account account) {
        return accountRepository.save(account);
    }
}

// ✅ 올바른 예시
@Service
@Transactional
public class ASMBC74001 implements NewIApplicationService {
    
    // PC 레이어만 의존
    @Autowired
    private PCAccount pcAccount;
    
    public NewKBData execute(NewKBData reqData) throws NewBusinessException {
        return pcAccount.create(reqData);
    }
}
```

#### **2. 잘못된 트랜잭션 관리**
```java
// ❌ 잘못된 예시
@Service
public class AccountService {
    
    public void createAccount(Account account) {
        // 트랜잭션 어노테이션 없음
        accountRepository.save(account);
        // 오류 발생 시 롤백되지 않음
    }
}

// ✅ 올바른 예시
@Service
@Transactional
public class ASMBC74001 implements NewIApplicationService {
    
    @Transactional(rollbackFor = {NewBusinessException.class})
    public NewKBData execute(NewKBData reqData) throws NewBusinessException {
        try {
            // 비즈니스 로직
            return pcAccount.create(reqData);
        } catch (Exception e) {
            // 자동 롤백
            throw new NewBusinessException("처리 실패: " + e.getMessage());
        }
    }
}
```

#### **3. 잘못된 로깅**
```java
// ❌ 잘못된 예시
@Service
public class AccountService {
    
    public void createAccount(Account account) {
        // 로깅 없음
        accountRepository.save(account);
    }
}

// ✅ 올바른 예시
@Service
@Transactional
public class ASMBC74001 implements NewIApplicationService {
    
    private static final NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    
    public NewKBData execute(NewKBData reqData) throws NewBusinessException {
        logger.info("=== ASMBC74001.execute START ===", "ASMBC74001");
        
        try {
            NewKBData result = pcAccount.create(reqData);
            logger.info("=== ASMBC74001.execute END ===", "ASMBC74001");
            return result;
        } catch (Exception e) {
            logger.error("=== ASMBC74001.execute - Error: {} ===", e.getMessage(), "ASMBC74001");
            throw new NewBusinessException("처리 실패: " + e.getMessage());
        }
    }
}
```

### **📋 비즈니스 로직 구현 체크리스트**

#### **새로운 AS 클래스 생성 시**
- [ ] `@Service` 어노테이션 사용
- [ ] `@Transactional` 어노테이션 사용
- [ ] `NewIApplicationService` 인터페이스 구현
- [ ] 로거 설정 (`NewIKesaLogger`)
- [ ] PC 레이어 의존성 주입
- [ ] `execute` 메서드 구현

#### **의존성 주입 규칙**
- [ ] AS → PC → DC 순서만 허용
- [ ] `@Autowired` 사용
- [ ] 생성자 주입 고려 (필요시)
- [ ] 순환 의존성 방지

#### **트랜잭션 관리**
- [ ] 읽기 전용: `@Transactional(readOnly = true)`
- [ ] 쓰기 작업: `@Transactional`
- [ ] 예외 처리: `@Transactional(rollbackFor = Exception.class)`
- [ ] 트랜잭션 경계 명확히 설정

#### **비즈니스 로직 구현**
- [ ] 입력 데이터 검증
- [ ] 비즈니스 규칙 검증
- [ ] PC 레이어 호출
- [ ] 결과 검증
- [ ] 에러 처리 및 로깅

#### **로깅 구현**
- [ ] 메서드 시작/종료 로깅
- [ ] 입력 파라미터 로깅
- [ ] 오류 발생 시 상세 로깅
- [ ] 성공/실패 결과 로깅

### **🔧 특별한 비즈니스 로직 패턴**

#### **1. 복합 비즈니스 로직**
```java
@Service
@Transactional
public class ASComplexBusiness implements NewIApplicationService {
    
    @Autowired
    private PCAccount pcAccount;
    
    @Autowired
    private PCUser pcUser;
    
    /**
     * 복합 비즈니스 로직 - 계정 생성과 사용자 연동
     */
    @Transactional(rollbackFor = {NewBusinessException.class})
    public NewKBData executeComplexBusiness(NewKBData reqData) throws NewBusinessException {
        try {
            // 1. 계정 생성
            NewKBData accountResult = pcAccount.create(reqData);
            
            // 2. 사용자 정보 업데이트
            NewKBData userResult = pcUser.update(reqData);
            
            // 3. 결과 통합
            return combineResults(accountResult, userResult);
            
        } catch (Exception e) {
            logger.error("복합 비즈니스 로직 실패: {}", e.getMessage());
            throw new NewBusinessException("복합 비즈니스 로직 실행 실패");
        }
    }
}
```

#### **2. 배치 처리 비즈니스 로직**
```java
@Service
@Transactional
public class ASBatchProcessing implements NewIApplicationService {
    
    /**
     * 배치 처리 비즈니스 로직
     */
    @Transactional(rollbackFor = {NewBusinessException.class})
    public NewKBData executeBatchProcessing(NewKBData reqData) throws NewBusinessException {
        List<{도메인}PDTO> {도메인}List = extract{도메인}List(reqData);
        
        for ({도메인}PDTO {도메인} : {도메인}List) {
            try {
                // 개별 처리
                processIndividual{도메인}({도메인});
            } catch (Exception e) {
                logger.error("배치 처리 중 오류: {}", e.getMessage());
                // 개별 실패는 로그만 남기고 계속 진행
            }
        }
        
        return createBatchResult({도메인}List);
    }
}
```

#### **3. 조건부 비즈니스 로직**
```java
@Service
@Transactional
public class ASConditionalBusiness implements NewIApplicationService {
    
    @Value("${feature.enabled:false}")
    private boolean featureEnabled;
    
    /**
     * 조건부 비즈니스 로직
     */
    public NewKBData executeConditionalBusiness(NewKBData reqData) throws NewBusinessException {
        if (featureEnabled) {
            return executeNewBusinessLogic(reqData);
        } else {
            return executeLegacyBusinessLogic(reqData);
        }
    }
}
```

### **📝 EPlaton Framework 통합 가이드**

#### **TCF (Transaction Control Framework) 사용**
```java
@Component
public class TCF {
    
    private static final Logger logger = LoggerFactory.getLogger(TCF.class);
    
    /**
     * 트랜잭션 실행
     */
    public Object execute(String transactionId, String transactionType, EPlatonEvent event) {
        try {
            logger.info("트랜잭션 실행: {} - 타입: {}", transactionId, transactionType);
            
            // 1. 트랜잭션 검증
            if (!validateTransaction(event)) {
                throw new RuntimeException("트랜잭션 검증 실패");
            }
            
            // 2. 트랜잭션 처리
            String result = processTransaction(transactionId);
            
            // 3. 트랜잭션 커밋
            if (!commitTransaction(event)) {
                throw new RuntimeException("트랜잭션 커밋 실패");
            }
            
            logger.info("트랜잭션 실행 성공: {}", transactionId);
            return result;
            
        } catch (Exception e) {
            logger.error("트랜잭션 실행 오류: {}", transactionId, e);
            
            // 트랜잭션 롤백
            rollbackTransaction(event);
            
            throw new RuntimeException("트랜잭션 실행 실패", e);
        }
    }
}
```

### **⚠️ 주의사항**

1. **레이어 간 의존성**: AS → PC → DC 순서만 허용
2. **트랜잭션 경계**: 비즈니스 로직 단위로 트랜잭션 설정
3. **예외 처리**: 모든 비즈니스 로직에서 적절한 예외 처리
4. **로깅**: 모든 비즈니스 로직에서 상세한 로깅
5. **검증**: 입력 데이터와 비즈니스 규칙 검증 필수
6. **성능**: 읽기 전용 트랜잭션 적절히 사용

이 가이드를 따라 비즈니스 로직을 구현하면 일관성 있고 유지보수하기 쉬운 백엔드 서비스를 구축할 수 있습니다.
description:
globs:
alwaysApply: false
---
