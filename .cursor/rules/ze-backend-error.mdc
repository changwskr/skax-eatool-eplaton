# Backend Error Handling Guide

## ğŸš¨ **SKAX EA Tool Eplaton Error Handling Implementation Rules**

### **ğŸ—ï¸ ì—ëŸ¬ ì²˜ë¦¬ ì•„í‚¤í…ì²˜ ê°œìš”**

```
ğŸ“¦ Error Handling Architecture
â”œâ”€â”€ ğŸ¯ Global Exception Handler (ì¤‘ì•™ ì—ëŸ¬ í•¸ë“¤ëŸ¬)
â”‚   â”œâ”€â”€ @ControllerAdvice
â”‚   â”œâ”€â”€ @ExceptionHandler
â”‚   â”œâ”€â”€ Error Response Standardization
â”‚   â””â”€â”€ Logging & Monitoring
â”œâ”€â”€ ğŸ”§ Custom Exception Classes (ì»¤ìŠ¤í…€ ì˜ˆì™¸)
â”‚   â”œâ”€â”€ BusinessException Hierarchy
â”‚   â”œâ”€â”€ FrameworkException Hierarchy
â”‚   â”œâ”€â”€ ValidationException
â”‚   â””â”€â”€ SystemException
â”œâ”€â”€ âš¡ Async Error Handling (ë¹„ë™ê¸° ì—ëŸ¬ ì²˜ë¦¬)
â”‚   â”œâ”€â”€ CompletableFuture Error Handling
â”‚   â”œâ”€â”€ @Async Exception Handling
â”‚   â”œâ”€â”€ Reactive Error Handling
â”‚   â””â”€â”€ Circuit Breaker Pattern
â””â”€â”€ ğŸ“Š Error Response Structure
    â”œâ”€â”€ Error Code Standardization
    â”œâ”€â”€ Error Message Localization
    â”œâ”€â”€ Error Context Information
    â””â”€â”€ Error Tracking & Monitoring
```

### **ğŸ¯ MUST FOLLOW - ì—ëŸ¬ ì²˜ë¦¬ êµ¬í˜„ ê·œì¹™**

#### **1. ì¤‘ì•™ ì—ëŸ¬ í•¸ë“¤ëŸ¬ (Global Exception Handler)**

**âœ… ì˜¬ë°”ë¥¸ ì¤‘ì•™ ì—ëŸ¬ í•¸ë“¤ëŸ¬ êµ¬ì¡°**
```java
/**
 * ê¸€ë¡œë²Œ ì˜ˆì™¸ ì²˜ë¦¬ í•¸ë“¤ëŸ¬
 * 
 * í”„ë¡œê·¸ë¨ëª…: GlobalExceptionHandler.java
 * ì„¤ëª…: ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ì˜ ì˜ˆì™¸ë¥¼ ì¤‘ì•™ì—ì„œ ì²˜ë¦¬í•˜ëŠ” í•¸ë“¤ëŸ¬
 * ì‘ì„±ì¼: 2024-01-01
 * ì‘ì„±ì: SKAX Project Team
 * 
 * ì£¼ìš” ê¸°ëŠ¥:
 * - ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸ ì²˜ë¦¬
 * - ê²€ì¦ ì˜ˆì™¸ ì²˜ë¦¬
 * - ì‹œìŠ¤í…œ ì˜ˆì™¸ ì²˜ë¦¬
 * - ì—ëŸ¬ ì‘ë‹µ í‘œì¤€í™”
 * 
 * @version 1.0
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    /**
     * ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸ ì²˜ë¦¬
     */
    @ExceptionHandler(NewBusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(NewBusinessException e, HttpServletRequest request) {
        log.warn("ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸ ë°œìƒ: {} - URI: {}", e.getMessage(), request.getRequestURI());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .errorCode("BUSINESS_ERROR")
            .message(e.getMessage())
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .method(request.getMethod())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    /**
     * ê²€ì¦ ì˜ˆì™¸ ì²˜ë¦¬
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e, HttpServletRequest request) {
        log.warn("ê²€ì¦ ì˜ˆì™¸ ë°œìƒ: {} - URI: {}", e.getMessage(), request.getRequestURI());
        
        List<String> errors = e.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.toList());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .errorCode("VALIDATION_ERROR")
            .message("ì…ë ¥ ë°ì´í„° ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
            .details(errors)
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .method(request.getMethod())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    /**
     * ë°ì´í„°ë² ì´ìŠ¤ ì˜ˆì™¸ ì²˜ë¦¬
     */
    @ExceptionHandler(DataAccessException.class)
    public ResponseEntity<ErrorResponse> handleDataAccessException(DataAccessException e, HttpServletRequest request) {
        log.error("ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ì˜ˆì™¸ ë°œìƒ: {} - URI: {}", e.getMessage(), request.getRequestURI(), e);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .errorCode("DATABASE_ERROR")
            .message("ë°ì´í„°ë² ì´ìŠ¤ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .method(request.getMethod())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
    
    /**
     * ì¸ì¦/ì¸ê°€ ì˜ˆì™¸ ì²˜ë¦¬
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDeniedException(AccessDeniedException e, HttpServletRequest request) {
        log.warn("ì ‘ê·¼ ê±°ë¶€ ì˜ˆì™¸ ë°œìƒ: {} - URI: {}", e.getMessage(), request.getRequestURI());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .errorCode("ACCESS_DENIED")
            .message("í•´ë‹¹ ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.")
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .method(request.getMethod())
            .build();
        
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(errorResponse);
    }
    
    /**
     * ì¼ë°˜ ì˜ˆì™¸ ì²˜ë¦¬ (ê¸°ë³¸ í•¸ë“¤ëŸ¬)
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e, HttpServletRequest request) {
        log.error("ì˜ˆìƒì¹˜ ëª»í•œ ì˜ˆì™¸ ë°œìƒ: {} - URI: {}", e.getMessage(), request.getRequestURI(), e);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .errorCode("INTERNAL_ERROR")
            .message("ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .method(request.getMethod())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
}
```

#### **2. ì—ëŸ¬ ì‘ë‹µ í‘œì¤€í™”**

**âœ… í‘œì¤€ ì—ëŸ¬ ì‘ë‹µ êµ¬ì¡°**
```java
/**
 * í‘œì¤€ ì—ëŸ¬ ì‘ë‹µ DTO
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ErrorResponse {
    
    private String errorCode;           // ì—ëŸ¬ ì½”ë“œ
    private String message;             // ì—ëŸ¬ ë©”ì‹œì§€
    private LocalDateTime timestamp;    // ë°œìƒ ì‹œê°„
    private String path;                // ìš”ì²­ ê²½ë¡œ
    private String method;              // HTTP ë©”ì„œë“œ
    private List<String> details;       // ìƒì„¸ ì—ëŸ¬ ì •ë³´
    private String traceId;             // ì¶”ì  ID
    
    /**
     * ì—ëŸ¬ ì‘ë‹µ ìƒì„± (ê°„ë‹¨í•œ ë²„ì „)
     */
    public static ErrorResponse of(String errorCode, String message) {
        return ErrorResponse.builder()
            .errorCode(errorCode)
            .message(message)
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    /**
     * ì—ëŸ¬ ì‘ë‹µ ìƒì„± (ìƒì„¸ ë²„ì „)
     */
    public static ErrorResponse of(String errorCode, String message, String path, String method) {
        return ErrorResponse.builder()
            .errorCode(errorCode)
            .message(message)
            .timestamp(LocalDateTime.now())
            .path(path)
            .method(method)
            .build();
    }
}
```

#### **3. ì»¤ìŠ¤í…€ ì˜ˆì™¸ í´ë˜ìŠ¤ ê³„ì¸µ êµ¬ì¡°**

**âœ… ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸ ê³„ì¸µ êµ¬ì¡°**
```java
/**
 * ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸ ê¸°ë³¸ í´ë˜ìŠ¤
 */
public abstract class BusinessException extends RuntimeException {
    
    private final String errorCode;
    private final String errorMessage;
    private final LocalDateTime timestamp;
    
    protected BusinessException(String errorCode, String errorMessage) {
        super(errorMessage);
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
        this.timestamp = LocalDateTime.now();
    }
    
    protected BusinessException(String errorCode, String errorMessage, Throwable cause) {
        super(errorMessage, cause);
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
        this.timestamp = LocalDateTime.now();
    }
    
    public String getErrorCode() {
        return errorCode;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public LocalDateTime getTimestamp() {
        return timestamp;
    }
}

/**
 * ì‚¬ìš©ì ê´€ë ¨ ì˜ˆì™¸ í´ë˜ìŠ¤ë“¤
 */
public class UserNotFoundException extends BusinessException {
    public UserNotFoundException(String userId) {
        super("USER_NOT_FOUND", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + userId);
    }
}

public class DuplicateUserException extends BusinessException {
    public DuplicateUserException(String email) {
        super("DUPLICATE_USER", "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‚¬ìš©ìì…ë‹ˆë‹¤: " + email);
    }
}

public class UserValidationException extends BusinessException {
    public UserValidationException(String field, String message) {
        super("USER_VALIDATION_ERROR", field + ": " + message);
    }
}

/**
 * ê³„ì • ê´€ë ¨ ì˜ˆì™¸ í´ë˜ìŠ¤ë“¤
 */
public class AccountNotFoundException extends BusinessException {
    public AccountNotFoundException(String accountNumber) {
        super("ACCOUNT_NOT_FOUND", "ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + accountNumber);
    }
}

public class InsufficientBalanceException extends BusinessException {
    public InsufficientBalanceException(String accountNumber, BigDecimal required, BigDecimal available) {
        super("INSUFFICIENT_BALANCE", 
              String.format("ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ê³„ì •: %s, í•„ìš”: %s, ë³´ìœ : %s", 
                          accountNumber, required, available));
    }
}

/**
 * ì‹œìŠ¤í…œ ê´€ë ¨ ì˜ˆì™¸ í´ë˜ìŠ¤ë“¤
 */
public class SystemException extends RuntimeException {
    private final String errorCode;
    
    public SystemException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public SystemException(String errorCode, String message, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
    }
    
    public String getErrorCode() {
        return errorCode;
    }
}
```

#### **4. ë¹„ë™ê¸° ì—ëŸ¬ ì²˜ë¦¬**

**âœ… CompletableFuture ì—ëŸ¬ ì²˜ë¦¬**
```java
@Service
@Slf4j
public class AsyncUserService {
    
    @Autowired
    private UserRepository userRepository;
    
    /**
     * ë¹„ë™ê¸° ì‚¬ìš©ì ì¡°íšŒ (CompletableFuture)
     */
    public CompletableFuture<UserDto> getUserAsync(String userId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                log.info("ë¹„ë™ê¸° ì‚¬ìš©ì ì¡°íšŒ ì‹œì‘: {}", userId);
                
                User user = userRepository.findById(userId)
                    .orElseThrow(() -> new UserNotFoundException(userId));
                
                log.info("ë¹„ë™ê¸° ì‚¬ìš©ì ì¡°íšŒ ì™„ë£Œ: {}", userId);
                return UserDto.from(user);
                
            } catch (UserNotFoundException e) {
                log.warn("ë¹„ë™ê¸° ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨ - ì‚¬ìš©ì ì—†ìŒ: {}", userId);
                throw e;
            } catch (Exception e) {
                log.error("ë¹„ë™ê¸° ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {}", userId, e);
                throw new SystemException("ASYNC_USER_QUERY_ERROR", "ë¹„ë™ê¸° ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", e);
            }
        }).exceptionally(throwable -> {
            log.error("CompletableFuture ì˜ˆì™¸ ì²˜ë¦¬: {}", throwable.getMessage());
            throw new RuntimeException("ë¹„ë™ê¸° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", throwable);
        });
    }
    
    /**
     * ì—¬ëŸ¬ ì‚¬ìš©ì ë¹„ë™ê¸° ì¡°íšŒ
     */
    public CompletableFuture<List<UserDto>> getUsersAsync(List<String> userIds) {
        List<CompletableFuture<UserDto>> futures = userIds.stream()
            .map(this::getUserAsync)
            .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()))
            .exceptionally(throwable -> {
                log.error("ë‹¤ì¤‘ ì‚¬ìš©ì ë¹„ë™ê¸° ì¡°íšŒ ì‹¤íŒ¨: {}", throwable.getMessage());
                throw new RuntimeException("ë‹¤ì¤‘ ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", throwable);
            });
    }
}
```

**âœ… @Async ì—ëŸ¬ ì²˜ë¦¬**
```java
@Service
@Slf4j
public class AsyncTaskService {
    
    @Autowired
    private UserRepository userRepository;
    
    /**
     * ë¹„ë™ê¸° ì‚¬ìš©ì ì²˜ë¦¬ (@Async)
     */
    @Async("taskExecutor")
    public CompletableFuture<UserDto> processUserAsync(String userId) {
        try {
            log.info("ë¹„ë™ê¸° ì‚¬ìš©ì ì²˜ë¦¬ ì‹œì‘: {}", userId);
            
            // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì‹¤í–‰
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
            
            // ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
            UserDto result = processUserBusinessLogic(user);
            
            log.info("ë¹„ë™ê¸° ì‚¬ìš©ì ì²˜ë¦¬ ì™„ë£Œ: {}", userId);
            return CompletableFuture.completedFuture(result);
            
        } catch (UserNotFoundException e) {
            log.warn("ë¹„ë™ê¸° ì‚¬ìš©ì ì²˜ë¦¬ ì‹¤íŒ¨ - ì‚¬ìš©ì ì—†ìŒ: {}", userId);
            return CompletableFuture.failedFuture(e);
        } catch (Exception e) {
            log.error("ë¹„ë™ê¸° ì‚¬ìš©ì ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {}", userId, e);
            return CompletableFuture.failedFuture(
                new SystemException("ASYNC_USER_PROCESS_ERROR", "ë¹„ë™ê¸° ì‚¬ìš©ì ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", e));
        }
    }
    
    /**
     * ë¹„ë™ê¸° ë°°ì¹˜ ì²˜ë¦¬
     */
    @Async("batchExecutor")
    public CompletableFuture<BatchResult> processBatchAsync(List<String> userIds) {
        BatchResult result = new BatchResult();
        
        try {
            log.info("ë¹„ë™ê¸° ë°°ì¹˜ ì²˜ë¦¬ ì‹œì‘: {}ê°œ ì‚¬ìš©ì", userIds.size());
            
            for (String userId : userIds) {
                try {
                    UserDto userDto = processUserAsync(userId).get(30, TimeUnit.SECONDS);
                    result.addSuccess(userId, userDto);
                } catch (Exception e) {
                    log.error("ë°°ì¹˜ ì²˜ë¦¬ ì¤‘ ê°œë³„ ì‚¬ìš©ì ì‹¤íŒ¨: {}", userId, e);
                    result.addFailure(userId, e.getMessage());
                }
            }
            
            log.info("ë¹„ë™ê¸° ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ: ì„±ê³µ {}ê°œ, ì‹¤íŒ¨ {}ê°œ", 
                    result.getSuccessCount(), result.getFailureCount());
            
            return CompletableFuture.completedFuture(result);
            
        } catch (Exception e) {
            log.error("ë¹„ë™ê¸° ë°°ì¹˜ ì²˜ë¦¬ ì¤‘ ì „ì²´ ì‹¤íŒ¨", e);
            return CompletableFuture.failedFuture(
                new SystemException("ASYNC_BATCH_PROCESS_ERROR", "ë¹„ë™ê¸° ë°°ì¹˜ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", e));
        }
    }
}

/**
 * ë¹„ë™ê¸° ì„¤ì •
 */
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("AsyncTask-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new SimpleAsyncUncaughtExceptionHandler();
    }
    
    @Bean("taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(50);
        executor.setThreadNamePrefix("Task-");
        executor.initialize();
        return executor;
    }
    
    @Bean("batchExecutor")
    public Executor batchExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(3);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("Batch-");
        executor.initialize();
        return executor;
    }
}
```

**âœ… Reactive ì—ëŸ¬ ì²˜ë¦¬**
```java
@Service
@Slf4j
public class ReactiveUserService {
    
    @Autowired
    private UserRepository userRepository;
    
    /**
     * Reactive ì‚¬ìš©ì ì¡°íšŒ
     */
    public Mono<UserDto> getUserReactive(String userId) {
        return Mono.fromCallable(() -> {
            log.info("Reactive ì‚¬ìš©ì ì¡°íšŒ ì‹œì‘: {}", userId);
            return userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        })
        .map(UserDto::from)
        .doOnSuccess(user -> log.info("Reactive ì‚¬ìš©ì ì¡°íšŒ ì™„ë£Œ: {}", userId))
        .doOnError(error -> log.error("Reactive ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨: {}", userId, error))
        .onErrorMap(UserNotFoundException.class, e -> 
            new BusinessException("USER_NOT_FOUND", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + userId))
        .onErrorMap(Exception.class, e -> 
            new SystemException("REACTIVE_USER_QUERY_ERROR", "Reactive ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", e));
    }
    
    /**
     * ì—¬ëŸ¬ ì‚¬ìš©ì Reactive ì¡°íšŒ
     */
    public Flux<UserDto> getUsersReactive(List<String> userIds) {
        return Flux.fromIterable(userIds)
            .flatMap(this::getUserReactive)
            .doOnComplete(() -> log.info("Reactive ë‹¤ì¤‘ ì‚¬ìš©ì ì¡°íšŒ ì™„ë£Œ: {}ê°œ", userIds.size()))
            .doOnError(error -> log.error("Reactive ë‹¤ì¤‘ ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨", error));
    }
    
    /**
     * Reactive ë°°ì¹˜ ì²˜ë¦¬
     */
    public Mono<BatchResult> processBatchReactive(List<String> userIds) {
        return Flux.fromIterable(userIds)
            .flatMap(userId -> getUserReactive(userId)
                .map(userDto -> new BatchItem(userId, userDto, null))
                .onErrorReturn(new BatchItem(userId, null, "ì²˜ë¦¬ ì‹¤íŒ¨")))
            .collectList()
            .map(this::createBatchResult)
            .doOnSuccess(result -> log.info("Reactive ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ: ì„±ê³µ {}ê°œ, ì‹¤íŒ¨ {}ê°œ", 
                result.getSuccessCount(), result.getFailureCount()))
            .doOnError(error -> log.error("Reactive ë°°ì¹˜ ì²˜ë¦¬ ì‹¤íŒ¨", error));
    }
}
```

#### **5. Circuit Breaker íŒ¨í„´**

**âœ… Circuit Breaker êµ¬í˜„**
```java
@Service
@Slf4j
public class CircuitBreakerUserService {
    
    @Autowired
    private UserRepository userRepository;
    
    private final CircuitBreaker circuitBreaker;
    
    public CircuitBreakerUserService() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)           // 50% ì‹¤íŒ¨ìœ¨ ì„ê³„ê°’
            .waitDurationInOpenState(Duration.ofSeconds(60))  // 60ì´ˆ ëŒ€ê¸°
            .ringBufferSizeInHalfOpenState(2)   // ë°˜ì—´ë¦¼ ìƒíƒœì—ì„œ 2ê°œ ìš”ì²­
            .ringBufferSizeInClosedState(10)    // ë‹«í˜ ìƒíƒœì—ì„œ 10ê°œ ìš”ì²­
            .build();
        
        this.circuitBreaker = CircuitBreaker.of("userService", config);
    }
    
    /**
     * Circuit Breakerë¥¼ ì‚¬ìš©í•œ ì‚¬ìš©ì ì¡°íšŒ
     */
    public UserDto getUserWithCircuitBreaker(String userId) {
        return circuitBreaker.executeSupplier(() -> {
            try {
                log.info("Circuit Breaker ì‚¬ìš©ì ì¡°íšŒ ì‹œì‘: {}", userId);
                
                User user = userRepository.findById(userId)
                    .orElseThrow(() -> new UserNotFoundException(userId));
                
                log.info("Circuit Breaker ì‚¬ìš©ì ì¡°íšŒ ì™„ë£Œ: {}", userId);
                return UserDto.from(user);
                
            } catch (UserNotFoundException e) {
                log.warn("Circuit Breaker ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨ - ì‚¬ìš©ì ì—†ìŒ: {}", userId);
                throw e;
            } catch (Exception e) {
                log.error("Circuit Breaker ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {}", userId, e);
                throw new SystemException("CIRCUIT_BREAKER_USER_QUERY_ERROR", 
                    "Circuit Breaker ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", e);
            }
        });
    }
    
    /**
     * Circuit Breaker ìƒíƒœ ëª¨ë‹ˆí„°ë§
     */
    public CircuitBreaker.State getCircuitBreakerState() {
        return circuitBreaker.getState();
    }
    
    /**
     * Circuit Breaker ë©”íŠ¸ë¦­ìŠ¤
     */
    public CircuitBreaker.Metrics getCircuitBreakerMetrics() {
        return circuitBreaker.getMetrics();
    }
}
```

### **ğŸš« NEVER DO - ì—ëŸ¬ ì²˜ë¦¬ ìœ„ë°˜ì‚¬í•­**

#### **1. ì˜ëª»ëœ ì˜ˆì™¸ ì²˜ë¦¬**
```java
// âŒ ì˜ëª»ëœ ì˜ˆì‹œ
@Service
public class UserService {
    
    public UserDto getUser(String userId) {
        try {
            User user = userRepository.findById(userId);
            return UserDto.from(user);  // null ì²´í¬ ì—†ìŒ
        } catch (Exception e) {
            // ì˜ˆì™¸ë¥¼ ë¬´ì‹œí•˜ê³  null ë°˜í™˜
            return null;
        }
    }
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆì‹œ
@Service
@Slf4j
public class UserService {
    
    public UserDto getUser(String userId) {
        try {
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
            return UserDto.from(user);
        } catch (UserNotFoundException e) {
            log.warn("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {}", userId);
            throw e;
        } catch (Exception e) {
            log.error("ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {}", userId, e);
            throw new SystemException("USER_QUERY_ERROR", "ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", e);
        }
    }
}
```

#### **2. ì˜ëª»ëœ ë¹„ë™ê¸° ì—ëŸ¬ ì²˜ë¦¬**
```java
// âŒ ì˜ëª»ëœ ì˜ˆì‹œ
@Async
public CompletableFuture<UserDto> getUserAsync(String userId) {
    User user = userRepository.findById(userId).orElse(null);
    return CompletableFuture.completedFuture(UserDto.from(user));  // null ì²˜ë¦¬ ì—†ìŒ
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆì‹œ
@Async
public CompletableFuture<UserDto> getUserAsync(String userId) {
    try {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
        return CompletableFuture.completedFuture(UserDto.from(user));
    } catch (Exception e) {
        log.error("ë¹„ë™ê¸° ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨: {}", userId, e);
        return CompletableFuture.failedFuture(e);
    }
}
```

#### **3. ì˜ëª»ëœ ê¸€ë¡œë²Œ í•¸ë“¤ëŸ¬**
```java
// âŒ ì˜ëª»ëœ ì˜ˆì‹œ
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public String handleException(Exception e) {
        return "Error: " + e.getMessage();  // í‘œì¤€í™”ë˜ì§€ ì•Šì€ ì‘ë‹µ
    }
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆì‹œ
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e, HttpServletRequest request) {
        log.error("ì˜ˆìƒì¹˜ ëª»í•œ ì˜ˆì™¸ ë°œìƒ: {} - URI: {}", e.getMessage(), request.getRequestURI(), e);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .errorCode("INTERNAL_ERROR")
            .message("ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .method(request.getMethod())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
}
```

### **ğŸ“‹ ì—ëŸ¬ ì²˜ë¦¬ êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸**

#### **ìƒˆë¡œìš´ ì˜ˆì™¸ í´ë˜ìŠ¤ ìƒì„± ì‹œ**
- [ ] `BusinessException` ë˜ëŠ” `SystemException` ìƒì†
- [ ] ì—ëŸ¬ ì½”ë“œì™€ ë©”ì‹œì§€ ëª…í™•íˆ ì •ì˜
- [ ] ì ì ˆí•œ ìƒì„±ì êµ¬í˜„
- [ ] ë¡œê¹… ë©”ì‹œì§€ í¬í•¨

#### **ê¸€ë¡œë²Œ í•¸ë“¤ëŸ¬ êµ¬í˜„**
- [ ] `@RestControllerAdvice` ì–´ë…¸í…Œì´ì…˜ ì‚¬ìš©
- [ ] êµ¬ì²´ì ì¸ ì˜ˆì™¸ë¶€í„° ì¼ë°˜ì ì¸ ì˜ˆì™¸ ìˆœì„œë¡œ ì²˜ë¦¬
- [ ] í‘œì¤€í™”ëœ `ErrorResponse` ì‚¬ìš©
- [ ] ì ì ˆí•œ HTTP ìƒíƒœ ì½”ë“œ ë°˜í™˜
- [ ] ìƒì„¸í•œ ë¡œê¹… êµ¬í˜„

#### **ë¹„ë™ê¸° ì—ëŸ¬ ì²˜ë¦¬**
- [ ] `CompletableFuture`ì˜ `exceptionally` ì‚¬ìš©
- [ ] `@Async` ë©”ì„œë“œì—ì„œ ì˜ˆì™¸ ì²˜ë¦¬
- [ ] Circuit Breaker íŒ¨í„´ ì ìš© (í•„ìš”ì‹œ)
- [ ] íƒ€ì„ì•„ì›ƒ ì„¤ì •
- [ ] ì¬ì‹œë„ ë¡œì§ êµ¬í˜„ (í•„ìš”ì‹œ)

#### **ì—ëŸ¬ ì‘ë‹µ í‘œì¤€í™”**
- [ ] ì¼ê´€ëœ ì—ëŸ¬ ì½”ë“œ ì²´ê³„
- [ ] ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€
- [ ] íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨
- [ ] ìš”ì²­ ì •ë³´ í¬í•¨ (ê²½ë¡œ, ë©”ì„œë“œ)
- [ ] ì¶”ì  ID í¬í•¨ (í•„ìš”ì‹œ)

### **ğŸ”§ íŠ¹ë³„í•œ ì—ëŸ¬ ì²˜ë¦¬ íŒ¨í„´**

#### **1. ê³„ì¸µë³„ ì—ëŸ¬ ì²˜ë¦¬**
```java
/**
 * AS ë ˆì´ì–´ ì—ëŸ¬ ì²˜ë¦¬
 */
@Service
@Transactional
public class ASUserManagement implements NewIApplicationService {
    
    private static final NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    
    public NewKBData execute(NewKBData reqData) throws NewBusinessException {
        try {
            // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì‹¤í–‰
            return processBusinessLogic(reqData);
        } catch (NewBusinessException e) {
            logger.error("AS ë ˆì´ì–´ ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            logger.error("AS ë ˆì´ì–´ ì‹œìŠ¤í…œ ì˜ˆì™¸: {}", e.getMessage(), e);
            throw new NewBusinessException("ì‚¬ìš©ì ê´€ë¦¬ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", e);
        }
    }
}

/**
 * PC ë ˆì´ì–´ ì—ëŸ¬ ì²˜ë¦¬
 */
@Service
public class PCUserManagement {
    
    private static final NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    
    public UserDto createUser(UserPDTO userPDTO) throws NewBusinessException {
        try {
            // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
            validateBusinessRules(userPDTO);
            
            // DC í˜¸ì¶œ
            return dcUser.createUser(userPDTO);
        } catch (NewBusinessException e) {
            logger.error("PC ë ˆì´ì–´ ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            logger.error("PC ë ˆì´ì–´ ì‹œìŠ¤í…œ ì˜ˆì™¸: {}", e.getMessage(), e);
            throw new NewBusinessException("ì‚¬ìš©ì ìƒì„± ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", e);
        }
    }
}
```

#### **2. ì—ëŸ¬ ì½”ë“œ í‘œì¤€í™”**
```java
/**
 * ì—ëŸ¬ ì½”ë“œ ìƒìˆ˜ ì •ì˜
 */
public final class ErrorCodes {
    
    // ë¹„ì¦ˆë‹ˆìŠ¤ ì—ëŸ¬ (Bë¡œ ì‹œì‘)
    public static final String USER_NOT_FOUND = "B001";
    public static final String DUPLICATE_USER = "B002";
    public static final String INVALID_USER_DATA = "B003";
    
    // ì‹œìŠ¤í…œ ì—ëŸ¬ (Së¡œ ì‹œì‘)
    public static final String DATABASE_ERROR = "S001";
    public static final String NETWORK_ERROR = "S002";
    public static final String TIMEOUT_ERROR = "S003";
    
    // ê²€ì¦ ì—ëŸ¬ (Vë¡œ ì‹œì‘)
    public static final String VALIDATION_ERROR = "V001";
    public static final String REQUIRED_FIELD_MISSING = "V002";
    public static final String INVALID_FORMAT = "V003";
    
    // ì¸ì¦/ì¸ê°€ ì—ëŸ¬ (Aë¡œ ì‹œì‘)
    public static final String UNAUTHORIZED = "A001";
    public static final String FORBIDDEN = "A002";
    public static final String TOKEN_EXPIRED = "A003";
}
```

#### **3. ì—ëŸ¬ ë©”ì‹œì§€ êµ­ì œí™”**
```java
/**
 * ì—ëŸ¬ ë©”ì‹œì§€ êµ­ì œí™”
 */
@Component
public class ErrorMessageResolver {
    
    @Autowired
    private MessageSource messageSource;
    
    public String resolveMessage(String errorCode, Locale locale) {
        return messageSource.getMessage(errorCode, null, "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜", locale);
    }
    
    public String resolveMessage(String errorCode, Object[] args, Locale locale) {
        return messageSource.getMessage(errorCode, args, "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜", locale);
    }
}

// messages.properties
user.not.found=ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {0}
user.duplicate=ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‚¬ìš©ìì…ë‹ˆë‹¤: {0}
validation.required=í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤: {0}
```

### **âš ï¸ ì£¼ì˜ì‚¬í•­**

1. **ì˜ˆì™¸ ì „íŒŒ**: ì ì ˆí•œ ì˜ˆì™¸ë¥¼ ìƒìœ„ë¡œ ì „íŒŒí•˜ê³  ë¬´ì‹œí•˜ì§€ ì•ŠìŒ
2. **ë¡œê¹…**: ëª¨ë“  ì˜ˆì™¸ ë°œìƒ ì‹œ ì ì ˆí•œ ë¡œê¹…
3. **ë³´ì•ˆ**: ë¯¼ê°í•œ ì •ë³´ê°€ ì—ëŸ¬ ì‘ë‹µì— ë…¸ì¶œë˜ì§€ ì•Šë„ë¡ ì£¼ì˜
4. **ì„±ëŠ¥**: ì—ëŸ¬ ì²˜ë¦¬ë¡œ ì¸í•œ ì„±ëŠ¥ ì €í•˜ ë°©ì§€
5. **ëª¨ë‹ˆí„°ë§**: ì—ëŸ¬ ë°œìƒ íŒ¨í„´ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì„¤ì •

ì´ ê°€ì´ë“œë¥¼ ë”°ë¼ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ êµ¬í˜„í•˜ë©´ ì•ˆì •ì ì´ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ ë°±ì—”ë“œ ì„œë¹„ìŠ¤ë¥¼ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
description:
globs:
alwaysApply: false
---
