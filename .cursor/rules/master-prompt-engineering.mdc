# 🎯 MASTER PROMPT ENGINEERING - 통합 프롬프트 엔지니어링 가이드

## 🧠 적용된 프롬프트 엔지니어링 기법

### 1. 🔗 Chain of Thought (사고 과정 명시)
### 2. 📚 Few-Shot Learning (예시 기반 학습)
### 3. 🎭 Role-Based Prompting (역할별 접근)
### 4. 🚀 Zero-Shot Learning (새로운 상황 대응)
### 5. ⚠️ Explicit Instructions (명확한 지시사항)

## 🎯 통합 접근 방법 (Integrated Approach)

### 1단계: 역할 선택 (Role Selection)
```
사고 과정:
1. 현재 상황에서 어떤 역할이 필요한가?
   - 🏗️ 아키텍트: 전체 구조 설계
   - 🎨 디자이너: 패턴 및 구조 설계
   - 👨‍💻 개발자: 실제 코드 구현
   - 🧪 테스터: 품질 및 테스트 검증
   - 🔍 리뷰어: 코드 품질 검토
2. 해당 역할의 체크리스트를 확인
3. 역할별 주의사항 준수
```

### 2단계: 패턴 인식 (Pattern Recognition)
```
사고 과정:
1. 기존 코드베이스에서 유사한 패턴 찾기
2. Few-Shot Learning 예시 참고
3. Zero-Shot Learning 템플릿 적용
4. 명명 규칙 및 패키지 구조 확인
```

### 3단계: 단계별 구현 (Step-by-Step Implementation)
```
사고 과정:
1. 요구사항 분석
2. 패키지 구조 결정
3. 클래스 설계
4. 메서드 설계
5. 로깅 설계
6. 예외 처리 설계
```

### 4단계: 품질 검증 (Quality Verification)
```
사고 과정:
1. 핵심 규칙 준수 확인
2. 명명 규칙 준수 확인
3. 패키지 구조 준수 확인
4. 어노테이션 적절성 확인
5. 예외 처리 적절성 확인
6. 로깅 적절성 확인
```

## 🚨 절대 하지 말아야 할 것들 (CRITICAL NEVER DO)

### 1. 🚫 패키지 구조 위반
```
❌ 절대 하지 말 것:
- com.skax.eatool 패키지 외부에 클래스 생성
- 컨트롤러를 service 패키지에 배치
- DTO를 entity 패키지에 배치
- 설정 클래스를 web 패키지에 배치

✅ 반드시 해야 할 것:
- 모든 클래스는 com.skax.eatool.{module} 패키지 하위에 생성
- 컨트롤러는 web/controller 패키지에 배치
- DTO는 web/dto 패키지에 배치
- 설정 클래스는 config 패키지에 배치
```

### 2. 🚫 명명 규칙 위반
```
❌ 절대 하지 말 것:
- 클래스명에 camelCase 사용 (예: userService)
- 메서드명에 PascalCase 사용 (예: GetUser)
- 상수에 camelCase 사용 (예: maxRetryCount)
- DTO 클래스명에 Dto 접미사 생략 (예: User 대신 UserDto 사용)

✅ 반드시 해야 할 것:
- 클래스명: PascalCase (예: UserService)
- 메서드명: camelCase (예: getUserById)
- 상수: ALL_CAPS (예: MAX_RETRY_COUNT)
- DTO: XXXDto 접미사 필수 (예: UserDto)
```

### 3. 🚫 Spring Boot 어노테이션 오용
```
❌ 절대 하지 말 것:
- @Service 없이 서비스 클래스 생성
- @RestController 없이 REST API 컨트롤러 생성
- @Transactional 없이 데이터베이스 작업 수행
- @Slf4j 없이 로깅 사용

✅ 반드시 해야 할 것:
- 서비스 클래스에는 @Service 필수
- REST API 컨트롤러에는 @RestController 필수
- 데이터베이스 작업에는 @Transactional 필수
- 로깅이 필요한 클래스에는 @Slf4j 필수
```

### 4. 🚫 예외 처리 무시
```
❌ 절대 하지 말 것:
- 예외를 catch하지 않고 무시
- RuntimeException만 사용하고 구체적 예외 생성 안 함
- 예외 메시지를 영어로만 작성
- 로깅 없이 예외 발생

✅ 반드시 해야 할 것:
- 모든 예외는 적절히 처리하거나 상위로 전파
- 구체적인 예외 클래스 생성 (UserNotFoundException)
- 예외 메시지는 한글로 작성
- 예외 발생 시 반드시 로깅
```

### 5. 🚫 로깅 규칙 위반
```
❌ 절대 하지 말 것:
- System.out.println() 사용
- 로그 레벨 구분 없이 모든 로그를 INFO로 작성
- 민감한 정보(비밀번호, 토큰)를 로그에 출력
- 로그 메시지에 변수 정보 없이 작성

✅ 반드시 해야 할 것:
- log.info(), log.error(), log.debug() 사용
- 적절한 로그 레벨 선택 (ERROR > WARN > INFO > DEBUG)
- 민감한 정보는 마스킹 처리
- 로그 메시지에 컨텍스트 정보 포함 (예: log.info("사용자 생성: email={}", email))
```

## 🎯 반드시 지켜야 할 핵심 패턴 (MUST FOLLOW)

### 1. 컴포넌트별 명명 규칙
```java
// ✅ 올바른 예시
@Controller
public class UserManagementPC { }  // PC: Presentation Controller

@RestController
public class UserApiDC { }         // DC: Data Controller

public class UserDto { }           // DTO: Data Transfer Object

@Mapper
public interface UserMapper { }     // Mapper: MyBatis Mapper

@Service
public class UserServiceImpl implements UserService { }  // Service: 비즈니스 로직

public class UserNotFoundException extends BusinessException { }  // Exception: 예외
```

### 2. 패키지 구조 규칙
```
com.skax.eatool.{module}/
├── config/           # 설정 클래스만
├── web/             # 웹 레이어만
│   ├── controller/  # 컨트롤러만
│   └── dto/         # DTO만
├── service/         # 서비스 레이어만
│   └── impl/        # 서비스 구현체만
├── repository/      # 데이터 액세스만
│   └── mapper/      # MyBatis 매퍼만
├── entity/          # 엔티티만
├── exception/       # 예외 클래스만
└── util/            # 유틸리티만
```

### 3. 코드 스타일 규칙
```java
/**
 * 클래스 설명 - 반드시 Javadoc 작성
 * 
 * @author 작성자
 * @version 1.0
 * @since 2024-01-01
 */
@Service
@Transactional
@Slf4j
public class UserService {
    
    // 상수는 대문자와 언더스코어 - 반드시 지켜야 함
    private static final String DEFAULT_ROLE = "USER";
    private static final int MAX_RETRY_COUNT = 3;
    
    // 필드는 private final 우선 - 반드시 지켜야 함
    private final UserRepository userRepository;
    
    // 생성자 주입 - 반드시 지켜야 함
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    // 메서드는 public, protected, private 순서 - 반드시 지켜야 함
    public UserDto createUser(CreateUserRequest request) {
        log.info("사용자 생성 시작: email={}", request.getEmail());
        
        try {
            validateUserRequest(request);
            User user = mapToUser(request);
            User savedUser = userRepository.save(user);
            
            log.info("사용자 생성 완료: userId={}", savedUser.getId());
            return UserDto.from(savedUser);
        } catch (Exception e) {
            log.error("사용자 생성 실패: email={}, error={}", 
                     request.getEmail(), e.getMessage(), e);
            throw e;
        }
    }
}
```

## 🔥 우선순위 규칙 (PRIORITY RULES)

### 1. 최우선 규칙 (HIGHEST PRIORITY)
- **절대 하지 말 것**: `com.skax.eatool` 패키지 외부에 클래스 생성
- **반드시 해야 할 것**: 모든 클래스는 `com.skax.eatool.{module}` 패키지 하위에 생성

### 2. 높은 우선순위 (HIGH PRIORITY)
- **절대 하지 말 것**: 명명 규칙 위반 (PC, DC, DTO, Mapper 등)
- **반드시 해야 할 것**: 컴포넌트별 명명 규칙 엄격 준수

### 3. 중간 우선순위 (MEDIUM PRIORITY)
- **절대 하지 말 것**: Spring Boot 어노테이션 생략
- **반드시 해야 할 것**: 적절한 어노테이션 사용

### 4. 낮은 우선순위 (LOW PRIORITY)
- **절대 하지 말 것**: 로깅 규칙 위반
- **반드시 해야 할 것**: SLF4J 로깅 사용

## 🎯 통합 체크리스트 (INTEGRATED CHECKLIST)

### 코드 생성 시 반드시 확인할 사항:
- [ ] 패키지명이 `com.skax.eatool.{module}` 형식인가?
- [ ] 클래스명이 컴포넌트별 명명 규칙을 따르는가?
- [ ] 적절한 Spring Boot 어노테이션이 사용되었는가?
- [ ] 생성자 주입이 사용되었는가?
- [ ] ResponseEntity로 응답이 래핑되었는가?
- [ ] @Valid로 입력 검증이 구현되었는가?
- [ ] 구체적 예외 클래스가 사용되었는가?
- [ ] SLF4J 로깅이 구현되었는가?
- [ ] DTO 매핑 메서드가 구현되었는가?
- [ ] 트랜잭션 어노테이션이 사용되었는가?
- [ ] Javadoc이 작성되었는가?
- [ ] 한글 주석이 사용되었는가?
- [ ] 들여쓰기가 4칸 스페이스인가?
- [ ] 최대 줄 길이가 120자 이하인가?

## 📚 참고 문서
- [핵심 규칙](mdc:.cursor/rules/critical-rules.mdc)
- [Spring Boot 패턴](mdc:.cursor/rules/spring-boot-patterns-optimized.mdc)
- [Chain of Thought](mdc:.cursor/rules/chain-of-thought.mdc)
- [Role-Based Prompting](mdc:.cursor/rules/role-based-prompting.mdc)
- [Zero-Shot Learning](mdc:.cursor/rules/zero-shot-learning.mdc)
description:
globs:
alwaysApply: false
---
