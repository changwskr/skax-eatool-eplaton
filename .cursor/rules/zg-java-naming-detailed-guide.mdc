# Java Naming Conventions - Detailed Implementation Guide

## 📋 **SKAX EA Tool Eplaton Java Naming Conventions - 상세 구현 가이드**

### **🏗️ 1. 개요 및 목적**

이 문서는 SKAX EA Tool Eplaton 프로젝트에서 사용하는 Java 네이밍 규칙의 상세한 구현 가이드입니다. 본 네이밍 표준은 다음 목적을 가지고 작성되었습니다:

#### **1.1 주요 목적**
- ✅ **일관성 있는 코드 작성**: 팀 전체에서 동일한 네이밍 규칙 적용
- ✅ **가독성과 유지보수성 향상**: 코드 이해도 및 수정 용이성 증대
- ✅ **아키텍처 계층 명확화**: AS, PC, DC, IC, FC 계층별 역할 구분
- ✅ **자동화 도구 연계 기반 마련**: SonarQube, Swagger, Javadoc 등과의 연동

#### **1.2 적용 범위**
- Java 소스 코드 전체
- 패키지 구조 및 클래스 명명
- 메서드, 변수, 상수 명명
- DTO, VO, Request/Response 객체 명명
- 주석 작성 표준
- 테스트 코드 명명

### **⚙️ 2. 가정 및 제약사항**

#### **2.1 기술 스택**
| 항목 | 내용 | 비고 |
|------|------|------|
| **Java 버전** | Java 8 이상 | Java 11 권장 |
| **프레임워크** | Spring Boot 기반 | 3.x 권장 |
| **빌드 도구** | Maven 또는 Gradle | Maven 3.8+ 권장 |
| **인코딩** | UTF-8 | 필수 |
| **IDE** | IntelliJ IDEA, Eclipse | IntelliJ IDEA 권장 |
| **표준 도구 연계** | Swagger, Javadoc, SonarQube, Checkstyle | 자동화 연동 |

#### **2.2 개발 환경 설정**
```xml
<!-- Maven pom.xml 예시 -->
<properties>
    <java.version>11</java.version>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
</properties>
```

### **🏛️ 3. Java Source Package 구조 및 계층**

#### **3.1 어플리케이션 계층 구조 정의**

```
📦 Application Layer Architecture
├── 🎯 AS (Application Service) - 어플리케이션 서비스
│   ├── 트랜잭션 조정
│   ├── 서비스 간 오케스트레이션
│   ├── 유효성 검증
│   └── 비즈니스 로직 조정
├── 🔧 PC (Process Component) - 어플리케이션 프로세스
│   ├── 업무 로직 실행 흐름 조정
│   ├── 도메인 컴포넌트 호출
│   ├── 데이터 변환
│   └── 비즈니스 규칙 적용
├── 💾 DC (Domain Component) - 도메인 컴포넌트
│   ├── 데이터 처리 로직
│   ├── DAO 및 비즈니스 핵심 로직
│   ├── Repository 패턴 구현
│   └── 데이터베이스 트랜잭션
├── 🔌 IC (Interface Component) - 인터페이스 컴포넌트
│   ├── 외부 시스템 연계
│   ├── API 수신/송신
│   ├── 프로토콜 처리
│   └── 외부 서비스 연동
└── 🛠️ FC (Foundation Component) - 공통 컴포넌트
    ├── 공통 설정
    ├── 유틸리티 클래스
    ├── 공통 예외처리
    └── 공통 Enum 및 상수
```

#### **3.2 Source Package 구조 상세**

```
src/main/java/com/skax/eatool/{appcode}/
├── as/                           # Application Service 계층
│   ├── {domain}as/              # 도메인별 서비스 구현
│   │   ├── AS{Module}{Code}.java # 예: ASMBC75001.java
│   │   └── {Domain}Service.java  # 예: UserService.java
│   └── {feature}as/             # 기능별 서비스 구현
├── pc/                           # Process Component 계층
│   ├── {domain}pc/              # 도메인별 프로세스
│   │   ├── PC{Module}{Code}.java # 예: PCMBC75001.java
│   │   ├── {Domain}Processor.java # 예: UserProcessor.java
│   │   └── dto/                 # PC Layer DTO
│   │       └── {Domain}PDTO.java # 예: UserPDTO.java
│   └── {feature}pc/             # 기능별 프로세스
├── dc/                           # Domain Component 계층
│   ├── {domain}dc/              # 도메인별 데이터 컴포넌트
│   │   ├── DC{Module}{Code}.java # 예: DCMBC75001.java
│   │   ├── {Domain}Repository.java # 예: UserRepository.java
│   │   └── dto/                 # DC Layer DTO
│   │       └── {Domain}DDTO.java # 예: UserDDTO.java
│   ├── repository/               # Repository 패키지
│   │   ├── {Domain}Repository.java
│   │   └── impl/                # Repository 구현체
│   │       └── {Domain}RepositoryImpl.java
│   ├── mapper/                  # MyBatis Mapper
│   │   ├── {Domain}Mapper.java
│   │   └── xml/                 # XML Mapper 파일
│   │       └── {Domain}Mapper.xml
│   └── entity/                  # Entity 클래스
│       └── {Domain}Entity.java
├── ic/                           # Interface Component
│   ├── api/                     # API 처리
│   │   ├── {Domain}ApiController.java
│   │   └── {Domain}ApiService.java
│   ├── external/                # 외부 연계 처리
│   │   ├── {ExternalSystem}Client.java
│   │   └── {ExternalSystem}Service.java
│   └── protocol/                # 프로토콜 처리
│       └── {Protocol}Handler.java
└── fc/                           # Foundation Component
    ├── config/                   # 설정 클래스
    │   ├── DatabaseConfig.java
    │   ├── SecurityConfig.java
    │   └── SwaggerConfig.java
    ├── util/                     # 공통 유틸리티
    │   ├── DateUtil.java
    │   ├── StringUtil.java
    │   └── ValidationUtil.java
    ├── exception/                # 공통 예외처리
    │   ├── GlobalExceptionHandler.java
    │   ├── BusinessException.java
    │   └── SystemException.java
    └── common/                   # 기타 공통 컴포넌트
        ├── constants/            # 상수 정의
        ├── enums/               # Enum 정의
        └── base/                # 기본 클래스
```

### **📝 4. 명명 규칙 (Naming Conventions) - 상세 구현**

#### **4.1 클래스 및 인터페이스 명명 원칙**

**기본 원칙**: UpperCamelCase 사용, 클래스의 역할을 명확히 표현

##### **4.1.1 서비스 클래스 명명**

```java
// ✅ 올바른 예시
@Service
public class UserService { }

@Service
public class AccountService { }

@Service
public class OrderService { }

// ❌ 잘못된 예시
@Service
public class userService { }

@Service
public class accountService { }
```

##### **4.1.2 컨트롤러 클래스 명명**

```java
// ✅ 올바른 예시
@RestController
@RequestMapping("/api/users")
public class UserController { }

@RestController
@RequestMapping("/api/accounts")
public class AccountController { }

// ❌ 잘못된 예시
@RestController
public class userController { }

@RestController
public class accountController { }
```

##### **4.1.3 Repository 클래스 명명**

```java
// ✅ 올바른 예시
@Repository
public interface UserRepository extends JpaRepository<User, Long> { }

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> { }

// ❌ 잘못된 예시
@Repository
public interface userRepository extends JpaRepository<User, Long> { }
```

##### **4.1.4 인터페이스 명명**

```java
// ✅ 올바른 예시
public interface IUserService { }

public interface IAccountRepository { }

public interface IOrderProcessor { }

// ❌ 잘못된 예시
public interface userService { }

public interface accountRepository { }
```

##### **4.1.5 추상 클래스 명명**

```java
// ✅ 올바른 예시
public abstract class AbstractUserService { }

public abstract class AbstractBaseEntity { }

public abstract class AbstractRepository<T, ID> { }

// ❌ 잘못된 예시
public abstract class abstractUserService { }

public abstract class baseEntity { }
```

#### **4.2 DTO / VO / Request / Response 명명 원칙**

**원칙**: 계층에 따라 접미사 명확화 (DTO, PDTO, DDTO, Request, Response 등)

##### **4.2.1 PC Layer DTO 명명**

```java
// ✅ 올바른 예시
public class UserPDTO extends NewAbstractDTO {
    private String userId;
    private String userName;
    private String email;
    // getters and setters
}

public class AccountPDTO extends NewAbstractDTO {
    private String accountNumber;
    private String accountType;
    private BigDecimal balance;
    // getters and setters
}

// ❌ 잘못된 예시
public class userPDTO extends NewAbstractDTO { }

public class accountPDTO extends NewAbstractDTO { }
```

##### **4.2.2 DC Layer DTO 명명**

```java
// ✅ 올바른 예시
public class UserDDTO extends NewAbstractDTO {
    private String userId;
    private String userName;
    private String email;
    private LocalDateTime createdDate;
    // getters and setters
}

public class AccountDDTO extends NewAbstractDTO {
    private String accountNumber;
    private String accountType;
    private BigDecimal balance;
    private String status;
    // getters and setters
}

// ❌ 잘못된 예시
public class userDDTO extends NewAbstractDTO { }

public class accountDDTO extends NewAbstractDTO { }
```

##### **4.2.3 Request/Response 객체 명명**

```java
// ✅ 올바른 예시
public class CreateUserRequest {
    private String userName;
    private String email;
    private String phone;
    // getters and setters
}

public class UpdateUserRequest {
    private String userId;
    private String userName;
    private String email;
    // getters and setters
}

public class UserResponse {
    private String userId;
    private String userName;
    private String email;
    private String status;
    // getters and setters
}

// ❌ 잘못된 예시
public class createUserRequest { }

public class userResponse { }
```

##### **4.2.4 Value Object 명명**

```java
// ✅ 올바른 예시
public class UserVO {
    private String userId;
    private String userName;
    private String email;
    // getters and setters
}

public class AccountVO {
    private String accountNumber;
    private String accountType;
    private BigDecimal balance;
    // getters and setters
}

// ❌ 잘못된 예시
public class userVO { }

public class accountVO { }
```

#### **4.3 메서드 명명 원칙**

**원칙**: lowerCamelCase, 동사 + 명사형으로 구성

##### **4.3.1 CRUD 메서드 명명**

```java
// ✅ 올바른 예시
public class UserService {
    
    // 등록 메서드
    public User createUser(CreateUserRequest request) { }
    public User registerUser(UserRegistrationRequest request) { }
    
    // 수정 메서드
    public User updateUser(String userId, UpdateUserRequest request) { }
    public User modifyUser(String userId, UserModificationRequest request) { }
    
    // 삭제 메서드
    public void deleteUser(String userId) { }
    public void removeUser(String userId) { }
    
    // 조회 메서드 (단건)
    public User getUserById(String userId) { }
    public User getAccountByNumber(String accountNumber) { }
    
    // 조회 메서드 (다건)
    public List<User> getListUser(UserSearchCriteria criteria) { }
    public List<Account> getListAccount(AccountSearchCriteria criteria) { }
    
    // 건수 조회
    public int countUsers(UserSearchCriteria criteria) { }
    public long countAccounts(AccountSearchCriteria criteria) { }
    
    // 존재 여부 확인
    public boolean isUserExists(String userId) { }
    public boolean hasUserPermission(String userId, String permission) { }
    public boolean canUserAccess(String userId, String resource) { }
}

// ❌ 잘못된 예시
public class UserService {
    public User createuser(CreateUserRequest request) { }
    public User updateuser(String userId, UpdateUserRequest request) { }
    public void deleteuser(String userId) { }
    public User getuserbyid(String userId) { }
    public List<User> getlistuser(UserSearchCriteria criteria) { }
}
```

##### **4.3.2 검증 및 계산 메서드 명명**

```java
// ✅ 올바른 예시
public class ValidationService {
    
    // 검증 메서드
    public boolean validateUser(UserPDTO userPDTO) { }
    public boolean validateAccount(AccountPDTO accountPDTO) { }
    public boolean validateRequest(CreateUserRequest request) { }
    
    // 계산 메서드
    public BigDecimal calculateBalance(String accountNumber) { }
    public BigDecimal calculateInterest(String accountNumber, int months) { }
    public BigDecimal calculateFee(TransactionRequest request) { }
    
    // 변환 메서드
    public User convertToUser(UserPDTO userPDTO) { }
    public UserPDTO convertToUserPDTO(User user) { }
}

// ❌ 잘못된 예시
public class ValidationService {
    public boolean validateuser(UserPDTO userPDTO) { }
    public BigDecimal calculatebalance(String accountNumber) { }
    public User converttouser(UserPDTO userPDTO) { }
}
```

#### **4.4 변수 명명 원칙**

**원칙**: lowerCamelCase, 의미 있는 변수명 작성, boolean은 is/has 접두사 사용

##### **4.4.1 일반 변수 명명**

```java
// ✅ 올바른 예시
public class UserService {
    private String userName;
    private String userEmail;
    private int maxRetryCount;
    private BigDecimal accountBalance;
    private LocalDateTime createdDate;
    private List<User> userList;
    private Map<String, Object> requestData;
    private Optional<User> userOptional;
}

// ❌ 잘못된 예시
public class UserService {
    private String username;
    private String useremail;
    private int maxretrycount;
    private BigDecimal accountbalance;
    private LocalDateTime createddate;
    private List<User> userlist;
    private Map<String, Object> requestdata;
}
```

##### **4.4.2 Boolean 변수 명명**

```java
// ✅ 올바른 예시
public class UserService {
    private boolean isActive;
    private boolean hasPermission;
    private boolean canEdit;
    private boolean isValid;
    private boolean exists;
    private boolean isEnabled;
    private boolean hasRole;
}

// ❌ 잘못된 예시
public class UserService {
    private boolean active;
    private boolean permission;
    private boolean edit;
    private boolean valid;
    private boolean enabled;
    private boolean role;
}
```

##### **4.4.3 컬렉션 변수 명명**

```java
// ✅ 올바른 예시
public class UserService {
    private List<User> userList;
    private Map<String, User> userMap;
    private Set<String> userIdSet;
    private Queue<Order> orderQueue;
    private Collection<Account> accountCollection;
    private Stream<User> userStream;
}

// ❌ 잘못된 예시
public class UserService {
    private List<User> users;
    private Map<String, User> users;
    private Set<String> userIds;
    private Queue<Order> orders;
}
```

#### **4.5 Private 변수 명명 원칙**

**원칙**: 클래스 스코프 변수는 `_` 접미사 부여로 로컬 변수와 구분

```java
// ✅ 올바른 예시
public class UserService {
    private String userName_;
    private int maxRetryCount_;
    private List<User> userList_;
    private Map<String, Object> requestData_;
    private boolean isActive_;
    
    public void setUserName(String userName) {
        this.userName_ = userName; // 구분 명확화
    }
    
    public void setMaxRetryCount(int maxRetryCount) {
        this.maxRetryCount_ = maxRetryCount;
    }
    
    public void setUserList(List<User> userList) {
        this.userList_ = userList;
    }
}

// ❌ 잘못된 예시
public class UserService {
    private String userName;
    private int maxRetryCount;
    
    public void setUserName(String userName) {
        this.userName = userName; // 변수명 충돌 가능성
    }
}
```

#### **4.6 상수 명명 원칙**

**원칙**: 모두 대문자, 단어는 `_`로 구분

```java
// ✅ 올바른 예시
public class Constants {
    public static final int MAX_RETRY_COUNT = 3;
    public static final String DEFAULT_USER_ROLE = "USER";
    public static final long TIMEOUT_DURATION = 30000L;
    public static final String ERROR_CODE_NOT_FOUND = "E001";
    public static final String SUCCESS_CODE_OK = "S001";
    public static final BigDecimal DEFAULT_BALANCE = BigDecimal.ZERO;
    public static final LocalDateTime DEFAULT_DATE = LocalDateTime.now();
}

// ❌ 잘못된 예시
public class Constants {
    public static final int maxRetryCount = 3;
    public static final String defaultUserRole = "USER";
    public static final long timeoutDuration = 30000L;
    public static final String errorCodeNotFound = "E001";
}
```

#### **4.7 Enum 명명 원칙**

**원칙**: Enum 클래스는 UpperCamelCase, 항목은 UPPER_SNAKE_CASE 사용

```java
// ✅ 올바른 예시
public enum UserStatus {
    ACTIVE, INACTIVE, PENDING, BLOCKED, DELETED
}

public enum AccountType {
    SAVINGS, CHECKING, CREDIT, INVESTMENT
}

public enum TransactionType {
    DEPOSIT, WITHDRAWAL, TRANSFER, PAYMENT
}

public enum OrderStatus {
    PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
}

// ❌ 잘못된 예시
public enum userStatus {
    active, inactive, pending, blocked
}

public enum accountType {
    savings, checking, credit
}
```

### **📝 5. 주석 표준 - 상세 구현**

#### **5.1 파일 주석 (Javadoc 형식)**

```java
/**
 * (@)# UserService.java
 * Copyright SKAX Inc. All rights reserved.
 * PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 * 
 * 프로그램 설명 : 사용자 관리 서비스 클래스
 * 
 * 주요 기능:
 * - 사용자 등록/수정/삭제/조회
 * - 사용자 권한 관리
 * - 사용자 상태 관리
 * 
 * 변경이력 :
 *   <ul>
 *     <li>2024-01-01 :: SKAX Team :: 신규작성</li>
 *     <li>2024-01-15 :: SKAX Team :: 사용자 검증 로직 추가</li>
 *     <li>2024-02-01 :: SKAX Team :: 권한 관리 기능 추가</li>
 *   </ul>
 * 
 * @author SKAX Team
 * @version 1.0
 * @since 2024-01-01
 */
package com.skax.eatool.mbc.as.usermgtas;

@Service
@Transactional
public class UserService {
    // 클래스 구현
}
```

#### **5.2 클래스 주석**

```java
/**
 * 사용자 관리 서비스 클래스
 * 
 * 사용자 정보의 CRUD 작업을 담당하며, 비즈니스 로직을 처리합니다.
 * 트랜잭션 관리와 예외 처리를 포함합니다.
 * 
 * @author SKAX Team
 * @version 1.0
 * @since 2024-01-01
 */
@Service
@Transactional
public class UserService {
    // 클래스 구현
}
```

#### **5.3 메서드 주석**

```java
/**
 * 사용자 정보를 등록한다.
 * 
 * 사용자 정보를 검증하고 데이터베이스에 저장합니다.
 * 중복 사용자 체크를 수행하며, 등록 성공 시 사용자 ID를 반환합니다.
 * 
 * @param userDTO 사용자 등록 정보 (null이 아니어야 함)
 * @return 등록된 사용자 ID
 * @throws NewBusinessException 사용자 정보가 유효하지 않거나 중복된 경우
 * @throws IllegalArgumentException userDTO가 null인 경우
 */
public Long registerUser(UserRequest userDTO) throws NewBusinessException {
    // 메서드 구현
}

/**
 * 사용자 목록을 조회한다.
 * 
 * 검색 조건에 따라 사용자 목록을 페이징하여 조회합니다.
 * 검색 조건이 null인 경우 전체 사용자를 조회합니다.
 * 
 * @param criteria 검색 조건 (null 가능)
 * @param pageable 페이징 정보 (null 가능)
 * @return 사용자 목록 (빈 목록 가능)
 * @throws NewBusinessException 데이터베이스 조회 중 오류 발생 시
 */
public List<User> getListUser(UserSearchCriteria criteria, Pageable pageable) 
    throws NewBusinessException {
    // 메서드 구현
}
```

#### **5.4 필드 주석**

```java
/**
 * 사용자 관리 서비스 클래스
 */
@Service
@Transactional
public class UserService {
    
    /** 사용자 Repository */
    @Autowired
    private UserRepository userRepository_;
    
    /** 최대 재시도 횟수 */
    private static final int MAX_RETRY_COUNT = 3;
    
    /** 기본 사용자 역할 */
    private static final String DEFAULT_USER_ROLE = "USER";
    
    /** 사용자 목록 */
    private List<User> userList_;
    
    /** 사용자 활성 상태 */
    private boolean isActive_;
}
```

#### **5.5 구현 주석 (Inline Comment)**

```java
public class UserService {
    
    /**
     * 사용자 정보를 등록한다.
     */
    public Long registerUser(UserRequest userDTO) throws NewBusinessException {
        
        // 1. 입력 데이터 검증
        if (userDTO == null) {
            throw new IllegalArgumentException("사용자 정보가 null입니다.");
        }
        
        // 2. 필수 필드 검증
        if (StringUtils.isEmpty(userDTO.getUserName())) {
            throw new NewBusinessException("사용자명은 필수입니다.");
        }
        
        // 3. 중복 사용자 체크
        if (existsUser(userDTO.getUserId())) {
            throw new NewBusinessException("이미 존재하는 사용자입니다: " + userDTO.getUserId());
        }
        
        // 4. 사용자 등록
        User user = convertToUser(userDTO);
        User savedUser = userRepository.save(user);
        
        // 5. 결과 반환
        return savedUser.getUserId();
    }
    
    /**
     * 사용자 목록을 조회한다.
     */
    public List<User> getListUser(UserSearchCriteria criteria) throws NewBusinessException {
        
        // 1. 검색 조건 설정
        UserDDTO userDDTO = new UserDDTO();
        if (criteria != null) {
            userDDTO.setSearchKeyword(criteria.getSearchKeyword());
            userDDTO.setRole(criteria.getRole());
            userDDTO.setStatus(criteria.getStatus());
        }
        
        // 2. 페이징 정보 설정
        if (criteria != null && criteria.getPageSize() > 0) {
            userDDTO.setPaging(criteria.getPage(), criteria.getPageSize());
        }
        
        // 3. 사용자 목록 조회
        List<User> userList = userRepository.getListUser(userDDTO);
        
        // 4. 결과 반환
        return userList;
    }
}
```

### **🎯 6. 실제 구현 예시**

#### **6.1 AS Layer 구현 예시**

```java
/**
 * (@)# ASMBC75001.java
 * Copyright SKAX Inc. All rights reserved.
 * PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 * 
 * 프로그램 설명 : 사용자 관리 Application Service
 * 
 * 주요 기능:
 * - 사용자 CRUD 작업
 * - 사용자 검증 및 권한 관리
 * 
 * 변경이력 :
 *   <ul>
 *     <li>2024-01-01 :: SKAX Team :: 신규작성</li>
 *   </ul>
 */
@Service
@Transactional
public class ASMBC75001 implements NewIApplicationService {
    
    private static final NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    
    @Autowired
    private PCUser pcUser;
    
    /**
     * 애플리케이션 서비스 실행
     * 
     * @param reqData 요청 데이터
     * @return 응답 데이터
     * @throws NewBusinessException 비즈니스 예외
     */
    @Override
    public NewKBData execute(NewKBData reqData) throws NewBusinessException {
        logger.info("=== ASMBC75001.execute START ===", "ASMBC75001");
        
        try {
            // 1. 입력 데이터 검증
            validateInputData(reqData);
            
            // 2. 명령어 추출
            String command = extractCommand(reqData);
            
            // 3. 명령어별 비즈니스 로직 실행
            NewKBData result = processCommand(command, reqData);
            
            logger.info("=== ASMBC75001.execute END ===", "ASMBC75001");
            return result;
            
        } catch (Exception e) {
            logger.error("=== ASMBC75001.execute - Error: {} ===", e.getMessage(), "ASMBC75001");
            throw new NewBusinessException("비즈니스 로직 실행 중 오류가 발생했습니다. 원인: " + e.getMessage());
        }
    }
    
    /**
     * 명령어별 처리 분기
     */
    private NewKBData processCommand(String command, NewKBData reqData) 
        throws NewBusinessException {
        
        switch (command.toUpperCase()) {
            case "CREATE":
                return processCreate(reqData);
            case "READ":
                return processRead(reqData);
            case "UPDATE":
                return processUpdate(reqData);
            case "DELETE":
                return processDelete(reqData);
            case "LIST":
                return processList(reqData);
            default:
                throw new NewBusinessException("지원하지 않는 명령어입니다: " + command);
        }
    }
}
```

#### **6.2 PC Layer 구현 예시**

```java
/**
 * (@)# PCMBC75001.java
 * Copyright SKAX Inc. All rights reserved.
 * PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 * 
 * 프로그램 설명 : 사용자 관리 Process Component
 * 
 * 주요 기능:
 * - 사용자 비즈니스 로직 처리
 * - 데이터 변환 및 검증
 * 
 * 변경이력 :
 *   <ul>
 *     <li>2024-01-01 :: SKAX Team :: 신규작성</li>
 *   </ul>
 */
@Service
public class PCMBC75001 {
    
    private static final NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    
    @Autowired
    private DCUser dcUser;
    
    /**
     * 사용자 생성 처리
     * 
     * @param userPDTO 사용자 정보
     * @return 생성된 사용자 정보
     * @throws NewBusinessException 비즈니스 예외
     */
    public UserPDTO createUser(UserPDTO userPDTO) throws NewBusinessException {
        logger.info("=== PCMBC75001.createUser START ===", "PCMBC75001");
        
        try {
            // 1. 사용자 정보 검증
            validateUserData(userPDTO);
            
            // 2. 중복 사용자 체크
            if (dcUser.existsUser(userPDTO.getUserId())) {
                throw new NewBusinessException("이미 존재하는 사용자입니다: " + userPDTO.getUserId());
            }
            
            // 3. 사용자 생성
            UserDDTO userDDTO = convertToUserDDTO(userPDTO);
            int result = dcUser.insertUser(userDDTO);
            
            if (result > 0) {
                logger.info("=== PCMBC75001.createUser END ===", "PCMBC75001");
                return userPDTO;
            } else {
                throw new NewBusinessException("사용자 생성에 실패했습니다.");
            }
            
        } catch (NewBusinessException e) {
            throw e;
        } catch (Exception e) {
            logger.error("=== PCMBC75001.createUser - Error: {} ===", e.getMessage(), "PCMBC75001");
            throw new NewBusinessException("사용자 생성 중 오류가 발생했습니다.", e);
        }
    }
}
```

#### **6.3 DC Layer 구현 예시**

```java
/**
 * (@)# DCMBC75001.java
 * Copyright SKAX Inc. All rights reserved.
 * PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 * 
 * 프로그램 설명 : 사용자 관리 Domain Component
 * 
 * 주요 기능:
 * - 사용자 데이터 처리
 * - 데이터베이스 접근
 * 
 * 변경이력 :
 *   <ul>
 *     <li>2024-01-01 :: SKAX Team :: 신규작성</li>
 *   </ul>
 */
@Service
public class DCMBC75001 implements DCUser {
    
    private static final NewIKesaLogger logger = NewKesaLogHelper.getBiz();
    
    @Autowired
    private UserRepository userRepository;
    
    /**
     * 사용자 목록 조회
     * 
     * @param userDDTO 사용자 조회 조건
     * @return 사용자 목록
     * @throws NewBusinessException 비즈니스 예외
     */
    @Override
    public List<User> getListUser(UserDDTO userDDTO) throws NewBusinessException {
        logger.info("=== DCMBC75001.getListUser START ===", "DCMBC75001");
        
        try {
            List<User> userList = userRepository.getListUser(userDDTO);
            logger.info("=== DCMBC75001.getListUser END ===", "DCMBC75001");
            return userList;
            
        } catch (Exception e) {
            logger.error("=== DCMBC75001.getListUser - Error: {} ===", e.getMessage(), "DCMBC75001");
            throw new NewBusinessException("사용자 목록 조회 중 오류가 발생했습니다.", e);
        }
    }
}
```

### **⚠️ 7. 주의사항 및 모범 사례**

#### **7.1 일관성 유지**
- 프로젝트 전체에서 동일한 네이밍 규칙 적용
- 팀 내 코드 리뷰를 통한 규칙 준수 확인
- 정적 분석 도구를 통한 자동 검증

#### **7.2 가독성 향상**
- 의미 있는 변수명과 메서드명 사용
- 축약어 사용 시 일관성 유지
- 복잡한 로직의 경우 주석 추가

#### **7.3 확장성 고려**
- 향후 기능 추가를 고려한 네이밍
- 도메인별 명확한 구분
- 계층별 역할 분리

#### **7.4 자동화 도구 연동**
- SonarQube 규칙 설정
- Checkstyle 설정
- Swagger 문서화 연동

이 가이드를 따라 Java 네이밍 규칙을 적용하면 일관성 있고 유지보수하기 쉬운 코드를 작성할 수 있습니다.
description:
globs:
alwaysApply: false
---
